<html>
    <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    
    </head>
    <body bgcolor="black" style="overflow-x: hidden; overflow-y: hidden">
        
        <pre id="output" style="color: hsla(120, 100%, 25%, 1); font-size: 40px; margin:0; padding:0; line-height: 45px"></pre>
        <svg id="svg" width="5000" height="5000" style="position: absolute; top: 0; z-index: -1;">
            <circle id="cursor" cx="10" cy="50" r="1" fill="black" stroke="white" opacity="0.6" stroke-width="2"></circle>
            <circle id="cursor2" cx="10" cy="50" r="1" fill="black" stroke="white" opacity="0.9" stroke-width="2"></circle>
            <!--  <text id="hint" x="5" y="15" fill="red" style="font-size: 40px;">a</text> -->
        </svg>
        <br>
        <button style="border: 1px solid green; background-color: black; color: green; z-index: 100;"  id="gyro" onclick="console.log('hello'); DeviceMotionEvent.requestPermission()">gyro</button>
        <script>

            var prevX = 0
            var prevY = 0

            setInterval(() => {
                //energy = 0
            }, 100)

            onmousemove = (event) => {                
                ev = {}
                ev.acceleration = {}
                const x = event.clientX / 1000
                const y = event.clientY / 1000
                ev.acceleration.x = (event.clientX - prevX) / 5
                ev.acceleration.y = (event.clientY - prevY) / 5
                ev.acceleration.z = 0
                prevX = x
                prevY = y
                ondevicemotion(ev)
            }

            var prev = [0,0,0]
            var energy = 0.001
            
            var energyThreshold = 0.05
            var minEnergy = 0.0
            var energyScale = 1.0
            
            ondevicemotion = (event) => {
                setInterval(() => {
                    document.getElementById("gyro").style.display = 'none'
                }, 100)
                var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
                var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
                prev = [x, y, z]
                var [x, y, z] = [dx, dy, dz]
                energy = energyScale * (dx * dx + dy * dy + dz * dz)
                if (energy > energyThreshold) {
                    energy = energyThreshold
                }
                if (energy < 0.03) {
                    energy = 0
                }
                
            
            }

            setInterval(() => {
                energy = 0
            }, 300)
        </script>

       <script>
        window.lag = 5 //5
        window.minprefixboundary = 5
        window.indiscriminateChoicefullnessBound = 9
        window.discriminateChoicefullnessBound = 1000
        
        
        
        function choice(arr){
          
          let unique = new Set(arr)
          let counts = Array.from(unique).map(x => {
            return [x, arr.filter(v => v===x).length]
          }).sort((a, b) => b[1] - a[1])
        
          return counts
            .slice(0, discriminateChoicefullnessBound)
            .pop()[0]
          
          
          //return arr.sort((a,b) =>
            //arr.filter(v => v===b).length - arr.filter(v => v===a).length
          //).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
        
        
        window.history = []
        let predict = (pattern, history = window.history) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0
          const N = history.length - pattern.length - lag
          
          let candidates = []
          for (let i = N-1; i >= 0; i--) {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              candidates.push(history[i + pattern.length])
              if (candidates.length >= indiscriminateChoicefullnessBound) {
                break;
              }
            }
          }
          
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          
          return choice(candidates.slice(0, indiscriminateChoicefullnessBound))
          
        }
       </script>
        <script>
        var screenWidth = document.body.clientWidth - 20
        var screenHeight = document.body.clientHeight - 40

        const rate = 10
         
         const start = () => {
            
            const inity = 300
            const radius = 30 * screenHeight / 755
            var y = screenHeight
            var maxcursor = 0

            var extragaravity = 0
            var extraspeed = 1.0
            var globalspeed = 1.0
            var globalgravity = 1.0

            const console = [":"]

            

            var i = 0

            setInterval(() => {

                i++

                const template = "_____<<<□□□↵↵01234567890abcdefghijklmnopqrstuvwxyz;!.===".split("")
                var set = template
                const cursor = Math.max(0,Math.min(set.length - 1, Math.round(set.length * ((10 + screenHeight - y) / screenHeight))))
                

                const gravity = 1.1 * globalgravity * ((7 + extragaravity + 5 * energy + 5 * y / screenHeight - 2 * cursor / set.length) * screenHeight / 755) / rate
                const shift = (y - (globalspeed * extraspeed * energy * 450 * (screenHeight / 755) * (screenHeight / 755)) / rate)

                y1 = Math.max(0, Math.min(screenHeight, (shift + gravity)))
                
                if (y1 < 30) {
                    y1 = screenHeight
                }
                if (y1 < y) {
                    y = y1 
                } else {
                    y = y1 + gravity * (0.3 * 1000 / shift)
                }

                const dist = maxcursor - cursor

                
                if (cursor > maxcursor) {
                    maxcursor = cursor
                    i = 0
                }



                if (i % 150 === 0 && maxcursor > 2 && maxcursor - cursor < (4 + y / (2 * screenHeight))) {
                    maxcursor = cursor
                    extragaravity = 0
                    extraspeed = 1.0
                }

                if (set[maxcursor] === "=") {
                    maxcursor = 0
                    energy = 0
                    y = screenHeight
                    if (globalspeed > 0.85) {
                        //globalspeed *= 0.98
                        globalgravity = 1.0
                    }
                    
                }

                if (dist > 5) {
                    extragaravity = 50 + 150 * dist
                    extraspeed = 3.0
                }

                const candidate = set[maxcursor]
                if (cursor < 2 && set[maxcursor] !== "_") {
                    
                    if (candidate === '<') {
                        console.pop(candidate)
                        if (globalspeed > 0.85) {
                            globalspeed = 1.0
                            globalgravity = 1.0
                        }
                    } else {
                        console.push(candidate === '□' ? ' ' : (candidate === '↵' ? "\n" : candidate))
                        globalspeed = 1.0
                    }
                    maxcursor = 0
                    extragaravity = 0
                    extraspeed = 1.0   
                    globalgravity = 1.0    
                }

                const style  = `color: hsla(${120  + ((dist < 5) ? 180 + 20 * dist : 0)}, ${95}%, ${50 + 20 * y / screenHeight}%, 1); font-size: ${40 }px; line-height: 1em;`

                document.getElementById("output").innerHTML = console.join("") + `<font style="${style}">${set[maxcursor]}</font>`
                
                const nextdist = 0.03 * (shift + gravity)
                const nextcursor =  Math.max(0,Math.min(set.length - 1, Math.round(set.length * ((10 + screenHeight - (0.98 * (shift + gravity))) / screenHeight))))

                const shiftconsole = document.getElementById("output").getBoundingClientRect().top
                const cy = shiftconsole + (console.join("").split("\n").length - 1) * (40 + 5) - 5
                const cx = (console.join("").substring(console.join("").lastIndexOf("\n") + 1).length) * 24
                const c = document.getElementById("svg").getElementById("cursor")
                const cursorpix = 40 * 20 * y / screenHeight

               
                c.setAttributeNS(null, "cx", cx + (cursorpix % 40) * 0.7)
                c.setAttributeNS(null, "cy", cy + shiftconsole + 40 - cursorpix / 20)

                const c2 = document.getElementById("svg").getElementById("cursor2")
                c2.setAttributeNS(null, "cx", cx + 30)
                c2.setAttributeNS(null, "cy", cy + shiftconsole + 40 - cursorpix / 20)
                c2.setAttributeNS(null, "stroke", `hsla(${130  + y}, 100%, ${70 + 20 * y / screenHeight}%, 1)`)

                /**
                const t = document.getElementById("svg").getElementById("hint")
                t.setAttributeNS(null, "x", cx + 37 )
                t.setAttributeNS(null, "y", cy + 35 + 15)
                t.innerHTML = set[nextcursor]
                const tstyle = `fill: hsla(${130  + y + ((dist < 5) ? 180 + 20 * dist : 0)}, ${95}%, ${50 + 20 * nextdist / 40}%, ${(dist < 5) ? 0.7 : 0.2}); font-size: ${20 }px`
                t.setAttributeNS(null, "style", tstyle)
                */
            }, 100 / rate)
         }
         start()



        </script>
    </body>
</html>