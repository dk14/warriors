<html>
  
  <head>
    <link href='https://fonts.googleapis.com/css?family=Courier Prime' rel='stylesheet'>
    <style>
      body {
        background-color: black;
        font-family: 'Courier Prime';
        
      }
      h1   {color: blue;}
      p    {color: red;}
      
      .slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

button, label {
  font-family: 'Courier Prime';
  background: black; margin:auto;font-size:35px; border: 1px solid green; display: inline-block;padding: 6px 12px;color:green;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}
      
    </style>
  </head>
  
  <body>
    
    <div style="display:block;">
      <button id="request">ACTIVATE</button>
      <font color = "pink"><span id="out"> OBSERVING </span></font>
      <br>
      <br>
        
      
    </div>
    
    <div class="slidecontainer">
      <font color="green">
      Paddle Speed: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSpeed">
      Paddle Gravity: <input type="range" min="1" max="100" value="50" class="slider" id="paddleGravity">
      Paddle Sampling Period: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSampling">
      Paddle Position: <input type="range" min="1" max="100" value="0" class="slider" id="paddlePos">
      Sefirot Output: <input type="range" min="1" max="100" value="0" class="slider" id="sfrOutput">
      </font>
    </div>
    
    <br>
    <button id="savemem" >Save Memory</button>
    <button id="loadmem" >Load Memory</button>
    <button id="resetmem" >Reset Memory</button>
    
    <script type="text/javascript" src="https://unpkg.com/butterchurn"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets/lib/butterchurnPresetsExtra.min.js"></script>
  
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js"></script>
    
    <script>
      
      //cd /home
      //python3 -m http.server
      //cat /dev/location > /dev/null &

      // https://www.w3schools.com/howto/howto_js_rangeslider.asp
      
      const channels = 3 
      
      const span = document.getElementById("out")
        
      const print = (msg) => {
        span.textContent = msg
      }
      
      var gpu = null 
      var blur = null
      
      const width = 1000
      const height = 1000
      
      try {
        gpu = new GPU();
        const n = width
        const m = height
        
        // https://github.com/gpujs/gpu.js/issues/285
        
        blur = gpu.createKernel(function(a, pass) {
                  
              let sum = [0, 0, 0]
              
              
              for (let c = 0; c < 3; c++) {
                for (let i = -pass; i <= pass; i++) {
                  for (let j = -pass; j <= pass; j++) {
                    sum[c] += a[c + 4 * (this.thread.x + i) + 4 * 1000 * (1000 - this.thread.y + j)]
                  }
                }
              }
              
              let box = (2 * pass + 1) * (2 * pass + 1)
              
              this.color(sum[0] / (256 * box), sum[1] / (256 * box), sum[2] / (256 * box), 1)
              
          }).setOutput([n, m]).setGraphical(true)
        
      } catch (err) {
        console.log(err)
        print(err)
      }
      
      
      
      
      
      const barycentric = (m1, m2, m3, ax = 0.5, ay = 0.0, bx = 0.0, by = 1.0, cx = 1.0, cy = 1.0) => {
        let norm = m1 + m2 + m3
        return [(m1 * ax + m2 * bx + m3 * cx) / norm, (m1 * ay + m2 * by + m3 * cy) / norm]
      }
      
      
      
      const audioElem = new Audio()
      
      window.canvas = document.createElement("canvas");
      canvas.width = 1000
      canvas.height = 1000
      
      window.audioContext = new (window.AudioContext || window.webkitAudioContext) ();
      
        
        
      const streamNode = audioContext.createMediaStreamDestination();
       
      
      var visualizer = null
      
      window.customRenderer = true
      
      const initWinampViz = () => {
         try {
          visualizer = butterchurn.default.createVisualizer(audioContext, canvas, {
            width: 1000,
            height: 1000
          });
          
          // get audioNode from audio source or microphone
          
          
          const mediaSource = audioContext.createMediaStreamSource(streamNode.stream)
          visualizer.connectAudio(mediaSource);
          
          // load a preset
          
          window.presets = butterchurnPresets.getPresets();
          const preset = presets['Flexi, martin + geiss - dedicated to the sherwin maxawow'];
          
          window.presetKeys = Array.from(Object.keys(presets))
          
          //visualizer.loadPreset(preset, 0.0); // 2nd argument is the number of seconds to blend presets
          
          
          
          visualizer.render();
          
        } catch (error) {
          print(error)
        }
      }
      
      if (!customRenderer) {
        initWinampViz()
      }
      
      
      var renderqueue = []
      
      let doBlur = (ctx, k) => {
        try {
              const imageData = ctx.getImageData(0, 0, 1000, 1000)
              blur(imageData.data, k)
              ctx.drawImage(blur.canvas, 0, 0)
        } catch (err){
              print(err)
              console.log("blurrerr=" + err)
        }
      }
      
      if (canvas.getContext) {
        const ctx = canvas.getContext("2d");
        
        let initRenderState = () => {
          return {
            m1: 1.0,
            m2: 1.0,
            m3: 1.0,
            light: 1.0,
            blurLevel: 1.0,
            hue: 1.0,
            sat: 1.0,
            brush: 1.0,
            alpha: 1.0
          }
        }
        
        states = []
        
        for (i = 0; i < channels; i++) {
          states.push(initRenderState())
        }
        
        const draw = () => {
        
          
          //ctx.fillStyle = "rgb(0 0 0)";
          //ctx.fillRect(25, 25, 100, 100);
          //ctx.clearRect(45, 45, 60, 60);
          //ctx.strokeRect(50, 50, 50, 50);
          
          if (customRenderer && gpu !== null && ctx !== null) {
            
            
            
            let toRender = [...renderqueue]
            renderqueue = []
            
            
            for (let el of toRender) {
              const ch = el[0]
              const value = el[1]
              const valueInt = (el[1] * 100).toFixed(0)
              
              const command = valueInt % 10
              const st = states[ch]
              
              switch (command) {
                case 0: st.m1 = value; break;
                case 1: st.m2 = value; break;
                case 2: st.m3 = value; break;
                case 3: st.light = value; break;
                case 4: st.blurLevel = value; break;
                case 5: st.hue = value; break;
                case 6: st.sat = value; break;
                case 7: st.brush = value; break;
                case 8: st.alpha = value; break;
                case 9: break;
                default: print("what" + command + "type = " + typeof(el[1]))
              }
              let fillStyle = `hsl(${(360 * st.hue).toFixed(0)} ${(100 * st.sat).toFixed(0) * 0 + 100}% ${(10 * st.light + 40).toFixed(0)}% / ${(3 * st.alpha).toFixed(0)}%)`
              //console.log(fillStyle)
              ctx.fillStyle = fillStyle
              
              const coords = barycentric(st.m1, st.m2, st.m3)
              ctx.beginPath();
              ctx.arc(-350 + coords[0] * 1700, -500 + coords[1] * 1500, 1000 * st.brush, 0, 2 * Math.PI);
              ctx.fill()
              
              
              if (st.blurLevel > 0.9) {
                doBlur(ctx, 10)
              }
              
              
            }
            
          } 
            
          if (visualizer != null) {
            visualizer.render();
          }
          
          
          window.requestAnimationFrame(draw)
        
        }
        try {
          window.requestAnimationFrame(draw)
        } catch (message) {
          print(message)
        }
        
        
      }
      
      var canvasStream = canvas.captureStream()
      
      
      
      const videoElem = document.createElement("video");
      videoElem.srcObject = canvasStream
      
      audioElem.controls = true;
      audioElem.autoplay = false;
      
      videoElem.autoplay = true
      videoElem.controls = true
      
      videoElem.onpause = () => {
        audioElem.pause()
        
      } 
      
      videoElem.onplay = () => {
        audioElem.play()
      }
      window.overrideCanvas = false
      
      videoElem.onvolumechange = () => {
        
        if (visualizer != null && videoElem.muted && !customRenderer) {
          
          
          
          function getRandomInt(max) {
            return Math.floor(Math.random() * max);
          }
          
          if (window.overrideCanvas && getRandomInt(7) == 2) {
            customRenderer = true
            window.winampCanvasStream = videoElem.srcObject
            videoElem.srcObject = canvasStream
            
            print('RUNNING')
          } else {
            const npresets = window.presetKeys.length
            const randomPresetName = window.presetKeys[getRandomInt(npresets)]
            const preset = presets[randomPresetName];
            print(randomPresetName)
            visualizer.loadPreset(preset, 0.0); 
          }
          
         
        
        } else if (videoElem.muted) {
          customRenderer = false
          
          if (window.overrideCanvas == false) {
            window.overrideCanvas = true
          
            window.overridenCanvas = window.canvas
            window.canvas = document.createElement("canvas");
            canvas.width = 1000
            canvas.height = 1000
          
            videoElem.srcObject = canvas.captureStream()
          
            initWinampViz()
          } else {
            videoElem.srcObject = window.winampCanvasStream
          }
          
        }
      }
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(canvas)
      document.body.appendChild(document.createElement("br"))
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(audioElem);
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(videoElem);
      
      
      console.log("666")
      
      
  
      
      
      setTimeout(() => {  
        
        window.oscillatorNode = []
        
        
        
        
        
        var history = []
        var n = 1000
        var m = 1000000
        
        const saveState = () => {
          localStorage.setItem('memory', JSON.stringify(history))
        }
        
          
        
        const tryload = () => {
          const stored = localStorage.getItem('memory')
          
          
          if (stored !== null && stored !== "null") {
            //alert(storedCells)
            
            const memory = JSON.parse(stored)
            if (channels === memory.length) {
              history = memory
              console.log(history)
            } else {
              console.log("ignoring history")
            }
            
          }
          
        }
        
        
        
        
        
        window.memory = history
        
        setInterval(saveState, 5000)
        
              
        
        const gainNode = audioContext.createGain()
        gainNode.connect(streamNode)
        
        
        const activeChannells = []
        
        
        const initChannells = () => {
          for (i = 0; i < channels; i ++) {
            window.oscillatorNode.push(audioContext.createOscillator())
            window.oscillatorNode[i].type = "sine"
            window.oscillatorNode[i].connect(gainNode);
            history.push([])
            activeChannells.push(0)
          }
        }
        
        initChannells()
        
        tryload()
        
        
        
        console.log("6669")
        
              
        const beep = (frequency, i = 0) => {
          if (window.oscillatorNode[i]) {
            let delay = 0.05
            
            if (frequency == 0) {
              activeChannells[i] = 0
            } else {
              activeChannells[i] = 1
            }
            
            const activity = activeChannells.reduce((accumulator, current) => accumulator + current, 0);
            
            if (activity > 1) {
              gainNode.gain.setTargetAtTime(1.0 / activity, window.audioContext.currentTime, discretisation / 1000)
            } else {
              gainNode.gain
                .setTargetAtTime(1.0, window.audioContext.currentTime + delay + discretisation * (channels + 1) / 1000, discretisation * (channels + 1) / 1000)
            }
             
            window.oscillatorNode[i]
              .frequency.linearRampToValueAtTime(frequency, 
                window.audioContext.currentTime + discretisation / 1000 + delay)
            //console.log("f" + Math.ceil(frequency, 0))
          }
        }
        
        
        
        const permission = () => {
          
          //const source = audioContext.createMediaStreamSource(combinedStream);
          audioElem.srcObject = streamNode.stream
          
          //oscillatorNode.connect(audioContext.destination);
          
          for (i = 0; i < channels; i ++) {
            oscillatorNode[i].start();
          }
          
          audioElem.play()
          
          DeviceMotionEvent.requestPermission()
          print('RUNNING')
          
        }
        
        const btn = document.getElementById( "request" );
        btn.addEventListener( "click", permission );
        
        
        
        
        const loadmem = (event) => {
          navigator.clipboard.readText().then((stateTxt) => {
            try {
               let memory = JSON.parse(atob(stateTxt))
            
              if (channels === memory.length) {
                history = memory
                alert("loaded from clipboard")
              } else {
                alert('LOAD STATE ERROR: WRONG AMOUNT OF CH: ' + memory.length)
              }
              
            } catch (err) {
              alert(err)
              
            }
           
            
          })
          
          
        }
        
        const savemem = () => {
          
          navigator.clipboard.writeText(btoa(JSON.stringify(history)))
          
          alert("saved to clipboard!")
        }
        
        const resetmem = () => {
          history = history.map(x => [])
          alert('reset')
        }
        
        const btn2 = document.getElementById("savemem");
        btn2.addEventListener( "click", savemem );
        
        const btn3 = document.getElementById("loadmem");
        btn3.addEventListener( "click", loadmem);
        
        
        const btn4 = document.getElementById("resetmem");
        btn4.addEventListener( "click", resetmem );
        
        const speedSlider = document.getElementById("paddleSpeed")
        speedSlider.oninput = (e) => {
           window.speed = speedSlider.value / 10
        }
        
        const gravitySlider = document.getElementById("paddleGravity")
        gravitySlider.oninput = () => {
          window.gravity = gravitySlider.value / 100
        }
        
        const samplingSlider = document.getElementById("paddleSampling")
        samplingSlider.oninput = () => {
          clearInterval(window.transitionScheduler)
          window.discretisation = samplingSlider.value / 1.0
          setInterval(window.transition, window.discretisation)
        }
        
        const posSlider = document.getElementById("paddlePos")
        posSlider.oninput = () => {
          window.pos = posSlider.value / 100
        }
        
        const outSlider = document.getElementById("sfrOutput")
        
        
        
        var prev = [0,0,0]
        var energy = 0.001
        
        var energyThreshold = 0.9
        var minEnergy = 0.0
        var energyScale = 1.0
        
        ondevicemotion = (event) => {
          
          var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
          var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
          prev = [x, y, z]
          energy = energyScale * (dx * dx + dy * dy + dz * dz)
          if (energy > energyThreshold || energy < minEnergy) {
            energy = energyThreshold * energyScale
          }
          
        }
        
        //print("999")
        
        const lag = 5 //5
        const minprefixboundary = 5
        const longlag = 4
        
        function mode(arr){
          return arr.sort((a,b) =>
            arr.filter(v => v===a).length - arr.filter(v => v===b).length
          ).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        function amode(arr){
          return arr.sort((a,b) =>
            arr.filter(v => v===b).length - arr.filter(v => v===a).length
          ).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
        
        
        
        let predict = (pattern, history) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0
          const N = history.length - pattern.length - lag
          let candidates = [...Array(N)].map((_, i) => {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              return history[i + pattern.length]
            } else {
              return 0
            }
          }).filter(x => x !== 0)
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          candidates.reverse()
          return amode(candidates.slice(0, longlag))
          
        }
        
        const maxfreq = 120
        const basefreq = 60
        window.discretisation = 40.0
        
        window.speed = 6.0
        window.gravity = 0.6
        const posscale = 1.00
        
        const precision = 100
        const lim = 1.0
        
        window.pos = 0.0
        var orient = 1.0
        var tick = 0
        var i = 0
        
        const inferOutput = (pos, output) => {
          if (output < 2) {
            return (1.0 - Math.abs(pos)) * precision
          } else {
            if (Math.abs(pos) < 0.2) {
              return output
            } else {
              return (1.0 - Math.abs(pos)) * precision
            }
          }
        }
        
        
        window.transition = () => {
          
          pos = pos + orient * speed * energy - gravity * pos
          tick += 1
          if (tick % 120 == 0) {
            orient = - orient
          }

          if (pos > lim) {
            pos = lim
            orient = - orient
          }
          
          if (pos < - lim) {
            pos = - lim
            orient = - orient
          }
          
          
          i += 1
          i %= channels
          
          posSlider.value = Math.abs(pos) * 100
            
          history[i].splice(0, history[i].length - m)
          const pattern = history[i].slice(1).slice(-n)
          const prediction = Number.parseFloat(predict(pattern, history[i]))
    
          const output = inferOutput(posscale * pos, prediction) / posscale 
            
          const freq = (basefreq + 
              output * (maxfreq - basefreq) / precision)
              
          if (freq >= maxfreq - 3) {
            beep(0, i)
          } else {
            history[i].push(output.toFixed(0))
            renderqueue.push([i, output * 1.0 / precision])
            outSlider.value = output * 100.0 / precision
            beep(freq, i)
          }
          
        }
        
        window.transitionScheduler = setInterval(transition, discretisation)
      }, 100)
      

    </script>
  </body>

</html>