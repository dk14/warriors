<html>
  
  <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
     <meta name="viewport" content="user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    
    <link rel="touch-icon" href="https://github.com/user-attachments/assets/c3543d29-0559-434a-ad20-433cb0b2a015">
    <link rel="apple-touch-icon" href="https://github.com/user-attachments/assets/c3543d29-0559-434a-ad20-433cb0b2a015">
    <link href='https://fonts.googleapis.com/css?family=Courier Prime' rel='stylesheet'>
    <meta name="apple-mobile-web-app-title" content="Sfr">
    
    <style>
      body {
        background-color: black;
        font-family: 'Courier Prime';
        overflow: hidden;
        max-width: 100%;
        overflow-x: hidden;
      }
      h1   {color: blue;}
      p    {color: red;}
      
      .slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

canvas {
  max-width: 99%;
}


button, label, input, textarea {
  font-family: 'Courier Prime';
  background: black; margin:auto;font-size:35px; border: 1px solid green; display: inline-block;padding: 6px 12px;color:green;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}
      
    </style>
  </head>
  
  <body>
    
    <div style="display:block;">
      <button id="request">AWAKE IT</button>
      <font color = "pink"><span id="out"> OBSERVING </span></font>
      <br>
      <br>
        
      
    </div>
    
    <div class="slidecontainer">
      <font color="green">
      Paddle Speed: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSpeed">
      Paddle Gravity: <input type="range" min="1" max="100" value="50" class="slider" id="paddleGravity">
      Paddle Sampling Period: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSampling">
      Paddle Position: <input type="range" min="1" max="100" value="0" class="slider" id="paddlePos">
      Sefirot Output: <input type="range" min="1" max="100" value="0" class="slider" id="sfrOutput">
      </font>
    </div>
    
    <textarea columns="120" rows="7" id="config" style="width:100%;display:none" onchange="window.reconfigure=this.value">
n=1000; //prefixlengthstart
minprefixboundary = 5; 
indiscriminateChoicefullnessBound = 9; 
discriminateChoicefullnessBound = 1000;
sfrAudioChBound = 3
sfrGraphicsChBound = 9
//renderTimeout=5;
//remder=false;
//showCommandLine=false;

    </textarea>
    <br>
    <button id="savemem" >Save Memory</button>
    <button id="loadmem" >Load Memory</button>
    <button id="resetmem" >Reset Memory</button>
    <button id="toggle" onclick="txt=document.getElementById('config');if(txt.style.display=='none')txt.style.display='block'; else txt.style.display='none'">Cfg</button>
    
    <script type="text/javascript" src="https://unpkg.com/butterchurn"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets/lib/butterchurnPresetsExtra.min.js"></script>
  
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    
    <script>
      
      //cd /home
      //python3 -m http.server
      //cat /dev/location > /dev/null &

      
      const channels = 10
      
      const span = document.getElementById("out")
        
      const print = (msg) => {
        span.textContent = msg
      }
      
      
      try {
        window.db = new Dexie("SfrMemDatabase");
      
        db.version(1).stores({
          saves: "++id, data",
        });
      } catch (err) {
        print(err)
      }
      
      
      
      var gpu = null 
      var blur = null
      
      var addcircles = null
      
      const width = 1000
      const height = 1000
      
      window.render = true
      
      
      window.Nrecent = 1000
      
      window.introspectRecentMemory = (ch) => {
        return memory[ch].slice(-Nrecent)
      }
      
      window.injectMemory = (ch, introject) => {
        memory[ch].push(...introject)
      }
      
      window.transformBound = 50.0
      window.transformStep = 0.1
      
      try {
        
        window.gpucanvas = document.createElement("canvas");
        gpucanvas.width = 1000
        gpucanvas.height = 1000
        
        const gl =  gpucanvas.getContext('webgl', { preserveDrawingBuffer: true });
        
        
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        gpu = new GPU({
          gpucanvas,
          mode: "webgl",
          context: gl
        });
        
        const n = width
        const m = height
        
        // https://github.com/gpujs/gpu.js/issues/285
        
        blur = gpu.createKernel(function(a, pass, filter, transform, factor) {
              
            let x = this.thread.x
            let y = this.thread.y
            
            
            
            if (transform !== 0.0) {
              let scalex = 1.0
              let addy = 0.0
              let shiftx = 0.0
              
              let scaley = 1.0
              let addx = 0.0
              let shifty = 0.0
              
    
              if (transform == 1.0) {
                scalex += 0.001 * factor;
              } else if (transform == 2.0) {
                addy += (0.001 + 0.001 * x / 1000) * factor 
              } else if (transform == 3.0) {
                shiftx += 0.01 * factor
              } else if (transform == 4.0) {
                scaley += 0.001 * factor
              } else if (transform == 5.0) {
                addx += (0.001 + 0.001 * y / 1000) * factor
              } else if (transform == 6.0) {
                shifty += 0.01 * factor 
              }
              
              x = scalex * this.thread.x + addy * this.thread.y + 1000 * shiftx
              y = scaley * this.thread.y + addx * this.thread.x + 1000 * shifty
              
            }
              
              
              let sum = [0, 0, 0, 0]
              
              
              for (let c = 0; c < 3; c++) {
                for (let i = -pass; i <= pass; i++) {
                  for (let j = -pass; j <= pass; j++) {
                    const value = a[c + 4 * (x + i) + 4 * 1000 * (1000 - y + j)]
                    if (value / 256 > filter) {
                      sum[c] += value
                    }
                  }
                }
              }
              
              let box = (2 * pass + 1) * (2 * pass + 1)
              
              this.color(sum[0] / (256 * box), sum[1] / (256 * box), sum[2] / (256 * box), 0.9)
              
          }).setOutput([n, m]).setGraphical(true)
        
        
        addcircles = gpu.createKernel(function(n, a, transform, factor) {
          
          for (let i = 0; i < n; i++) {
          
            let x = this.thread.x
            let y = this.thread.y
            
            const radius = a[i][0]
            
            if (transform !== 0.0) {
              let scalex = 1.0
              let addy = 0.0
              let shiftx = 0.0
              
              let scaley = 1.0
              let addx = 0.0
              let shifty = 0.0
              
    
              if (transform == 1.0) {
                scalex += 0.001 * factor;
              } else if (transform == 2.0) {
                addy += (0.001 + 0.001 * x / 1000) * factor * 1000 / radius
              } else if (transform == 3.0) {
                shiftx += 0.01 * factor * 1000 / radius;
              } else if (transform == 4.0) {
                scaley += 0.001 * factor
              } else if (transform == 5.0) {
                addx += (0.001 + 0.001 * y / 1000) * factor * 1000 / radius
              } else if (transform == 6.0) {
                shifty += 0.01 * factor * 1000 / radius
              }
              
              x = scalex * this.thread.x + addy * this.thread.y + 1000 * shiftx
              y = scaley * this.thread.y + addx * this.thread.x + 1000 * shifty
              
            }
          
            
            const centerx = a[i][1]
            const centery = a[i][2]
            const r = a[i][3]
            const g = a[i][4]
            const b = a[i][5]
            const alpha = a[i][6]
            
            let dx = x - centerx
            const dy = y - centery
            
            if (transform == 7.0) {
              dx = dx * (1.0 + factor * 0.01 / radius)
            }
            
            if ((dx)**2 + (dy)**2 < radius**2) {
              this.color(r, g, b, alpha)
            } else {
              //this.color(1.0, 1.0, 1.0, 1.0)
            }
          }
          
        }).setOutput([n, m]).setGraphical(true)
        
      } catch (err) {
        console.log(err)
        print(err)
      }
      
      
      
      
      
      const barycentric = (m1, m2, m3, ax = 0.5, ay = 0.15, bx = 0.0, by = 1.0, cx = 1.0, cy = 1.0) => {
        let norm = m1 + m2 + m3
        return [(m1 * ax + m2 * bx + m3 * cx) / norm, (m1 * ay + m2 * by + m3 * cy) / norm]
      }
      
      
      
      const audioElem = new Audio()
      
      window.canvas = window.gpucanvas//document.createElement("canvas");
      canvas.width = 1000
      canvas.height = 1000
      
      window.audioContext = new (window.AudioContext || window.webkitAudioContext) ();
      
        
        
      const streamNode = audioContext.createMediaStreamDestination();
       
      
      var visualizer = null
      
      window.customRenderer = true
      
      window.renderTimeout = 100
      
      const initWinampViz = () => {
         try {
          visualizer = butterchurn.default.createVisualizer(audioContext, canvas, {
            width: 1000,
            height: 1000
          });
          
          // get audioNode from audio source or microphone
          
          
          const mediaSource = audioContext.createMediaStreamSource(streamNode.stream)
          visualizer.connectAudio(mediaSource);
          
          // load a preset
          
          window.presets = butterchurnPresets.getPresets();
          const preset = presets['Flexi, martin + geiss - dedicated to the sherwin maxawow'];
          
          window.presetKeys = Array.from(Object.keys(presets))
          
          //visualizer.loadPreset(preset, 0.0); // 2nd argument is the number of seconds to blend presets
          
          
          
          visualizer.render();
          
        } catch (error) {
          print(error)
        }
      }
      
      if (!customRenderer) {
        initWinampViz()
      }
      
      
      var renderqueue = []
      
  
      
      let hitTransformFactorBound = (ch, value) => {
        
        if (samplingSlider.value < 10) {
          transformBound *= 1.3
          transformStep *= 1.1 + 0.1 * (100 - samplingSlider.value) / 100
        }
        
        let basedelta = 0
        let maxdelta = 0
        
        if ((transformBound * 10).toFixed(0) % 19 == 3) {
          //transformBound = transformBound.toFixed(0) % 60
          transformStep = 0.105
          
          if (chbasefreq[ch] == 0) {
            chbasefreq[ch] = basefreq
          }
          if (chmaxfreq[ch] == 0) {
            chmaxfreq[ch] = maxfreq
          }
          
          if (value % 20 == 0) {
            basedelta = 0.01 * (value / 1000)
          } else {
            maxdelta = 0.03 * (value / 1000)
          }
          
          if ((value / 73) % 2 == 0) {
            basedelta = -basedelta
            maxdelta = -maxdelta
          }
          chbasefreq[ch % sfrAudioChBound] = Math.max(40, Math.min(90, chbasefreq[ch] + 1000 * basedelta))
          chmaxfreq[ch % sfrAudioChBound] = Math.max(120, Math.min(1500, chmaxfreq[ch] + 1000 * maxdelta))
        }
        
        //console.log("expand transform " + transformBound + " " + transformStep + " " + basedelta + " " + maxdelta)
      }
      
      let doBlur = (k, threshold, transform = 0.0, transformFactor = 0.0) => {
        try {
          //const imageData = ctx.getImageData(0, 0, 1000, 1000)
          blur(addcircles.getPixels(), k, threshold, transform, transformFactor)
          //ctx.drawImage(blur.canvas, 0, 0)
        } catch (err){
          print(err)
          console.log("blurrerr=" + err)
        }
      }
      
      let doCircle = (cx, cy, r, h, s, l, a, transform, factor) => {
        try {
          
          function hsl2rgb(h,s,l) {
            let a=s*Math.min(l,1-l);
            let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);
            return [f(0),f(8),f(4)];
          }   
          const rgb = hsl2rgb(h, s, l)
          //print(cx)
          addcircles(1, [r, cx, cy, rgb[0], rgb[1], rgb[2], a], transform, factor)
          //ctx.drawImage(window.gpucanvas, 0, 0)
        } catch (err){
          print(err)
          console.log("circleerr=" + err)
        }
      }
      
      if (true) {
        //const ctx = canvas.getContext("2d");
        
        let initRenderState = () => {
          return {
            m1: 1.0,
            m2: 1.0,
            m3: 1.0,
            light: 1.0,
            blurLevel: 1.0,
            hue: 1.0,
            sat: 1.0,
            brush: 1.0,
            alpha: 1.0,
            transform: 0.0,
            transformFactor: 0.0,
            direction: 1.0
          }
        }
        
        states = []
        var waited = 0
        
        for (i = 0; i < channels; i++) {
          states.push(initRenderState())
        }
        
        const draw = () => {
          
          
          //ctx.fillStyle = "rgb(0 0 0)";
          //ctx.fillRect(25, 25, 100, 100);
          //ctx.clearRect(45, 45, 60, 60);
          //ctx.strokeRect(50, 50, 50, 50);
          
          if (render && customRenderer && gpu !== null) {
            
            
            
            let toRender = [...renderqueue]
            renderqueue = []
            
            
            for (let el of toRender) {
              const ch = el[0]
              const value = el[1]
              const valueInt = (el[1] * 1000).toFixed(0)
              
              const command = valueInt % 10
              const st = states[ch]
              //console.log(command)
              switch (command) {
                case 1: st.m1 = value; break;
                case 2: st.m2 = value; break;
                case 3: st.m3 = value; break;
                case 4: st.light = value; break;
                case 5: st.blurLevel = value; break;
                case 6: st.hue = value; break;
                case 7: st.sat = value; break;
                case 8: st.brush = value; break;
                case 9: st.alpha = value; break;
                case 0: 
                  
                    st.transform = (valueInt / 20) % 8
                    //console.log("aaa")
                    
                    if (valueInt / 160 != 0 ) {
                      if ((valueInt / 160) % 2 == 0 && st.transformFactor <= transformBound){
                        st.transformFactor += st.direction * transformStep
                      } else if ((valueInt / 160) % 2 == 1 && st.transformFactor >= -transformBound) {
                        st.transformFactor -= st.direction * transformStep
                      } else {
                        st.direction = -st.direction
                        hitTransformFactorBound(ch, valueInt)
                      }
                    }
                  
                    break;
                default: print("what" + command + "type = " + typeof(el[1]))
              }
              //let fillStyle = `hsl(${((360 * st.hue).toFixed(0) / 10) * 10} ${(100 * st.sat).toFixed(0) * 0 + 100}% ${(10 * st.light + 40).toFixed(0)}% / ${(5 * st.alpha).toFixed(0)}%)`
              //console.log(fillStyle)
              //ctx.fillStyle = fillStyle
              
              const coords = barycentric(st.m1, st.m2, st.m3)
              //ctx.beginPath();
              const base = 10 + st.light * 2
              const radius = Math.pow(2, st.brush * base)
              //ctx.arc(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, 0, 2 * Math.PI);
              //ctx.arc(coords[0] * 1000, coords[1] * 1000, 1000 * st.brush, 0, 2 * Math.PI);
              
              //ctx.fill()
              
              const transform = st.transform 
              const factor = st.transformFactor
              
              doCircle(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, ((360 * st.hue).toFixed(0) / 10) * 10, 1.0, st.light* 0.1 + 0.4, 0.01 + 0.05 * st.alpha, transform, factor)
              
              //print(waited)
              if (waited < renderTimeout) {
                const t0 = performance.now()
                const level = (st.blurLevel * 100)
                if (level > 70) {
                  let filterFactor = 0.1
                  if (level > 80) {
                      filterFactor = 0.4
                  }
                  
                  doBlur(1 + ((6 * (st.blurLevel)).toFixed(0) / 3) * 3, filterFactor * st.sat)
                }
                
                const t1 = performance.now()
                waited = (t1 - t0)
              } else {
                waited -= 1.0
                if (waited < 0) {
                  waited = 0
                }
              }
              
              
            }
            if (states[0].blurLevel > 0.01) {
              
              let viewportTransform = 0
              let blurWindow = 3
              let filter = 0.01
              if (states[1].blurLevel < 0.05) {
                if (states[2].blurLevel < 0.04) {
                  blurWindow = 0
                  filter = 0.0
                }
                viewportTransform = states[2].transform
              }
              doBlur(3, 0.01, viewportTransform, states[3].transformFactor)
            }
            
          } 
            
          if (visualizer != null) {
            visualizer.render();
          }
          
          
          window.requestAnimationFrame(draw)
        
        }
        try {
          window.requestAnimationFrame(draw)
        } catch (message) {
          print(message)
        }
        
        
      }
      
      var canvasStream = canvas.captureStream()
      
      
      
      const videoElem = document.createElement("video");
      videoElem.srcObject = canvasStream
      
      audioElem.controls = false;
      audioElem.autoplay = false;
      audioElem.style = "position:relative;"
      
      videoElem.autoplay = false
      videoElem.controls = true
      videoElem.style.display = "none"
      
      videoElem.onpause = () => {
        audioElem.pause()
        
      } 
      
      var lastPlay = 0
      var count = 0
      videoElem.onplay = () => {
        dt = Date.now() - lastPlay
        if (dt < 500) {
          count += 1
          //console.log("" + count + " " + dt)
        } else {
          count = 0
        }
        if (count >= 4) {
          window.maxfreq = Math.min(2000, window.maxfreq + 20)
          console.log("alter freq" + window.maxfreq)
          count = 0
        }
        
        lastPlay = Date.now()
        audioElem.play()
      }
      window.overrideCanvas = false
      
      videoElem.onvolumechange = () => {
        
        if (visualizer != null && videoElem.muted && !customRenderer) {
          
          
          
          function getRandomInt(max) {
            let rnd = Math.random() * max
            if (renderqueue[0] && renderqueue[1] && renderqueue[0][1] % 3 == 2) {
              rnd = (renderqueue[1][1] + rnd) % max
            }
            return Math.floor(Math.random() * max);
          }
          
          if (window.overrideCanvas && getRandomInt(7) == 2) {
            customRenderer = true
            window.winampCanvasStream = videoElem.srcObject
            videoElem.srcObject = canvasStream
            
            print('RUNNING')
          } else {
            const npresets = window.presetKeys.length
            const randomPresetName = window.presetKeys[getRandomInt(npresets)]
            const preset = presets[randomPresetName];
            print(randomPresetName)
            visualizer.loadPreset(preset, 0.0); 
          }
          
         
        
        } else if (videoElem.muted) {
          customRenderer = false
          
          renderqueue.slice(0, 10000)
          
          if (window.overrideCanvas == false) {
            window.overrideCanvas = true
          
            window.overridenCanvas = window.canvas
            window.canvas = document.createElement("canvas");
            canvas.width = 1000
            canvas.height = 1000
          
            videoElem.srcObject = canvas.captureStream()
          
            initWinampViz()
          } else {
            videoElem.srcObject = window.winampCanvasStream
          }
          
        }
      }
      
      
      
      const fullscreen = document.createElement("button");
      
      fullscreen.style = "font-size:40px;position:relative;left:0%;"
      
      fullscreen.innerText = "EXPAND"
      fullscreen.onclick = () => {
        videoElem.style.display = "block"
        videoElem.play()
        if (videoElem.requestFullscreen) 
          videoElem.requestFullscreen();
        else if (videoElem.webkitRequestFullscreen) 
          div.webkitRequestFullscreen();
        else if (videoElem.msRequestFullScreen) 
          videoElem.msRequestFullScreen();
      }
      
      const pause = document.createElement("button");
      pause.innerText="||"
      pause.style = "font-size:40px;position:relative;left:0%;"
      
      pause.onclick = () => {
        if (audioElem.paused) {
          audioElem.play()
          pause.innerText="||"
        } else {
          audioElem.pause()
          pause.innerText="|>"
        }
          
      }
      
      
      document.addEventListener("fullscreenchange", function() {
        console.log("aaa")
        if (!document.fullscreen) {
          videoElem.pause()
          videoElem.style.display="none"
        }
      });
      
      if (document.webkitCurrentFullScreenElement && document.webkitCurrentFullScreenElement.onwebkitfullscreenchange) {
        document.webkitCurrentFullScreenElement.onwebkitfullscreenchange = () => {
          if (!document.webkitIsFullScreen) {
            videoElem.pause()
            videoElem.style.display="none"
          }
        }
      }
      
      videoElem.addEventListener("webkitendfullscreen", function(){
        videoElem.pause()
        videoElem.style.display="none"
      }, false);

      
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(canvas)
      document.body.appendChild(document.createElement("br"))
      
      document.body.appendChild(document.createElement("br"))
      
      document.body.appendChild(fullscreen);
      document.body.appendChild(audioElem);
      document.body.appendChild(pause);
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      
      
      document.body.appendChild(videoElem);
      
      document.body.appendChild(document.createElement("br"))
      console.log("666")
      
      
  
      
      
      setTimeout(() => {  
        
        
        
        window.oscillatorNode = []
        
        window.reconfigure = ""
        
        window.sfrAudioChBound = 3
        window.sfrGraphicsChBound = 9
        
        window.maxfreq = 120
        window.basefreq = 60
        
        window.chbasefreq = Array.from({length: channels}, () => 0)
        window.chmaxfreq = Array.from({length: channels}, () => 0)
      
        
        //40 350
        window.discretisation = 40.0
        
        window.auto = (param, step, segment = 1, line = 0, structdeepness = 1) => {
          if ((window.out / structdeepness) % segment === line) {
            return param + step
          } else {
            return param - step
          }
        }
        
        setInterval(() => {
          (1,eval)(window.reconfigure)
        }, 1000)
        
        
        var history = []
        window.n = 1000
        var m = 10000000
        
        window.showCommandLine=true
        window.commandLine = ""
        const characterSet = "@ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ()/\*+=[]{}#%_~<>!?,.0123456789-';"
        
        setInterval(() => {
          //let i = ((pos)*100).toFixed(0)
          let i = document.getElementById("sfrOutput").value
          if (i < characterSet.length) {
            const candidate = characterSet[i]
            //print("" + i + " " + candidate)
            if (candidate !== commandLine[commandLine.length-1]) {
              commandLine = commandLine + candidate
            }
            
          } else {
            commandLine = commandLine.slice(0, -1)
            if (commandLine.length == 1) {
              commandLine = ""
            }
          }
          
          if (commandLine.length > 30) {
            commandLine = ""
          }
          const toPrint = commandLine.replace('@', '')
          if (toPrint.length === 0) {
            //print('OBSERVING')
          } else {
            if (showCommandLine) {
              print('>' + toPrint)
              try {
                (1,eval)(toPrint)
              } catch {
                
              }
            }
          }
        }, 10)
        
        const saveState = () => {
          const encoded = JSON.stringify(history)
          //localStorage.setItem('memory', encoded)
          db.saves.put({id:0, data: encoded})
          
        }
        
          
        
        const tryload = () => {
          //const stored = localStorage.getItem('memory')
          
          
          db.saves.toArray().then((sv) => {
            const stored = sv.map(x => x.data)[0] ?? null
          
            if (stored !== null && stored !== "null") {
              //alert(storedCells)
              
              const memory = JSON.parse(stored)
              if (channels === memory.length) {
                history = memory
                console.log(history)
              } else {
                alert("ignoring history " + memory.length)
              }
              
            } else {
              console.log("no history found!")
            }
            
          })
        }
        
        
        window.memory = history
        
        setInterval(saveState, 5000)
        
              
        
        const gainNode = audioContext.createGain()
        
        
        
        let filter = audioContext.createBiquadFilter();
        
        filter.type = "lowpass"
        filter.frequency.setTargetAtTime(2000, audioContext.currentTime, 0);
        
        
        
        let compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(40, audioContext.currentTime);
        compressor.ratio.setValueAtTime(12, audioContext.currentTime);
        compressor.attack.setValueAtTime(0, audioContext.currentTime);
        compressor.release.setValueAtTime(0.25, audioContext.currentTime);
        
        
        gainNode.connect(filter)
        filter.connect(compressor)
        compressor.connect(streamNode)
        
        const beep = (frequency, i = 0) => {
          //console.log("" + i + "   " + frequency + "  " + gainNode.gain.value)
          
          if (window.oscillatorNode[i]) {
            let delay = 0.05
            
            if (frequency == 0) {
              activeChannells[i] = 0
            } else {
              if (window.oscillatorNode[i].frequency === 0) {
                delay += 0.1
              }
              activeChannells[i] = 1
            }
            
            const activity = activeChannells.reduce((accumulator, current) => accumulator + current, 0);
            
            if (activity > 1) {
              gainNode.gain.setTargetAtTime(1.0 / activity, window.audioContext.currentTime, discretisation / 1000)
            } else {
              gainNode.gain
                .setTargetAtTime(1.0, window.audioContext.currentTime + delay + discretisation * (channels + 1) / 1000, discretisation * (channels + 1) / 1000)
            }
             
            window.oscillatorNode[i]
              .frequency.linearRampToValueAtTime(frequency, 
                window.audioContext.currentTime + discretisation / 1000 + delay)
            //console.log("f" + Math.ceil(frequency, 0))
          }
        }
        
        
        
        const activeChannells = []
        
        
        const initChannells = () => {
          const rehistory = history.length != 0
          for (i = 0; i < channels; i ++) {
            window.oscillatorNode.push(audioContext.createOscillator())
            window.oscillatorNode[i].type = "sine"
            window.oscillatorNode[i].connect(gainNode);
            if (!rehistory) {
              history.push([])
              activeChannells.push(0)
            }
            
            window.oscillatorNode[i].frequency.value = 0
          }
        }
        
        initChannells()
        
        tryload()
        
        
        
        console.log("6669")
        
              
        
        
        
        window.started = false
        const permission = () => {
          
          //const source = audioContext.createMediaStreamSource(combinedStream);
          audioElem.srcObject = streamNode.stream
          
          //oscillatorNode.connect(audioContext.destination);
          
          if (window.started) {
            for (i = 0; i < channels; i ++) {
              oscillatorNode[i].stop();
            }
            oscillatorNode = []
            initChannells()
            alert("awake!")
          }
          
          for (i = 0; i < channels; i ++) {
            oscillatorNode[i].start();
          }
          
          audioElem.volume =1.0
          audioElem.play()
          window.started = true
          
          DeviceMotionEvent.requestPermission()
          print('RUNNING')
          
        }
        
        const btn = document.getElementById( "request" );
        btn.addEventListener( "click", permission );
        
        
        
        
        const loadmem = (event) => {
          navigator.clipboard.readText().then((stateTxt) => {
            try {
               let memory = JSON.parse(atob(stateTxt))
              audioElem.pause()
              if (channels === memory.length) {
                history = memory
                alert("loaded from clipboard")
              } else {
                alert('LOAD STATE ERROR: WRONG AMOUNT OF CH: ' + memory.length)
              }
              audioElem.play()
              
            } catch (err) {
              alert(err)
              audioElem.play()
              
            }
           
            
          })
          
          
        }
        
        const savemem = () => {
          audioElem.pause()
          
          navigator.clipboard.writeText(btoa(JSON.stringify(history)))
          audioElem.play()
          
          alert("saved to clipboard!")
          audioElem.play()
        }
        
        const resetmem = () => {
          audioElem.pause()
          history = history.map(x => [])
          audioElem.play()
          alert('reset')
        }
        
        const btn2 = document.getElementById("savemem");
        btn2.addEventListener( "click", savemem );
        
        const btn3 = document.getElementById("loadmem");
        btn3.addEventListener( "click", loadmem);
        
        
        const btn4 = document.getElementById("resetmem");
        btn4.addEventListener( "click", resetmem );
        
        const speedSlider = document.getElementById("paddleSpeed")
        speedSlider.oninput = (e) => {
           window.speed = speedSlider.value / 10
        }
        
        const gravitySlider = document.getElementById("paddleGravity")
        gravitySlider.oninput = () => {
          window.gravity = gravitySlider.value / 100
        }
        
        window.samplingSlider = document.getElementById("paddleSampling")
        samplingSlider.oninput = () => {
          clearInterval(window.transitionScheduler)
          window.discretisation = samplingSlider.value / 1.0
          setInterval(window.transition, window.discretisation)
        }
        
        const posSlider = document.getElementById("paddlePos")
        posSlider.oninput = () => {
          window.pos = posSlider.value / 100
        }
        
        const outSlider = document.getElementById("sfrOutput")
        
        
        
        var prev = [0,0,0]
        var energy = 0.001
        
        var energyThreshold = 0.9
        var minEnergy = 0.0
        var energyScale = 1.0
        
        ondevicemotion = (event) => {
          
          var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
          var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
          prev = [x, y, z]
          energy = energyScale * (dx * dx + dy * dy + dz * dz)
          if (energy > energyThreshold || energy < minEnergy) {
            energy = energyThreshold * energyScale
          }
          
        }
        
        //print("999")
        
        window.lag = 5 //5
        window.minprefixboundary = 5
        window.indiscriminateChoicefullnessBound = 9
        window.discriminateChoicefullnessBound = 1000
        
        
        
        function choice(arr){
          
          let unique = new Set(arr)
          let counts = Array.from(unique).map(x => {
            return [x, arr.filter(v => v===x).length]
          }).sort((a, b) => b[1] - a[1])
        
          return counts
            .slice(0, discriminateChoicefullnessBound)
            .pop()[0]
          
          
          //return arr.sort((a,b) =>
            //arr.filter(v => v===b).length - arr.filter(v => v===a).length
          //).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
        
        
        
        let predict = (pattern, history) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0
          const N = history.length - pattern.length - lag
          
          let candidates = []
          for (let i = N-1; i >= 0; i--) {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              candidates.push(history[i + pattern.length])
              if (candidates.length >= indiscriminateChoicefullnessBound) {
                break;
              }
            }
          }
          
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          
          return choice(candidates.slice(0, indiscriminateChoicefullnessBound))
          
        }
        
        
        
        window.speed = 6.0
        window.gravity = 0.6
        const posscale = 1.00
        
        const precision = 1000
        const lim = 1.0
        
        window.pos = 0.0
        var orient = 1.0
        var tick = 0
        var i = 0
        
        window.posThreshold = 0.2
        window.outputThreshold = 2
        
        const inferOutput = (pos, output) => {
          if (output < outputThreshold) {
            return (1.0 - Math.abs(pos)) * precision
          } else {
            if (Math.abs(pos) < posThreshold) {
              return output
            } else {
              return (1.0 - Math.abs(pos)) * precision
            }
          }
        }
        
        
        window.transition = () => {
          
          pos = pos + orient * speed * energy - gravity * pos
          tick += 1
          if (tick % 120 == 0) {
            orient = - orient
          }

          if (pos > lim) {
            pos = lim
            orient = - orient
          }
          
          if (pos < - lim) {
            pos = - lim
            orient = - orient
          }
          
          
          i += 1
          i %= channels
          
          posSlider.value = Math.abs(pos) * 100
            
          history[i].splice(0, history[i].length - m)
          const pattern = history[i].slice(1).slice(-n)
          const prediction = Number.parseFloat(predict(pattern, history[i]))
    
          const output = inferOutput(posscale * pos, prediction) / posscale 
            
          window.out = output
          const basefreqi = chbasefreq[i] == 0 ? basefreq : chbasefreq[i]
          const maxfreqi = chmaxfreq[i] == 0 ? maxfreq : chmaxfreq[i]
          //console.log("" + basefreqi + " " + maxfreqi + " " + chbasefreq)
          const freq = (basefreqi + 
              output * (maxfreqi - basefreqi) / precision)
              
          if (freq >= maxfreqi - 3) {
            beep(0, i)
          } else {
            history[i].push(output.toFixed(0))
            if (i < sfrGraphicsChBound) {
              renderqueue.push([i, output * 1.0 / precision])
            }
            
            if (!customRenderer) {
              renderqueue.splice(0, 59)
            }
              
            outSlider.value = output * 100.0 / precision
              
            if (i < sfrAudioChBound) {
              beep(freq, i)
            }
          }
          
        }
        
        window.transitionScheduler = setInterval(transition, discretisation)
      }, 1000)
      

    </script>
    
    <script type="text/javascript" src="https://unpkg.com/ts-browser"></script>

    
    
    <script type="text/typescript">
    
	    // export {};

declare global {
    interface Window {
        //modelExtractionQueue: [number, number][]; 

        Nrecent: number;
        introspectRecentMemory: (ch: number) => number[]
        injectMemory: (ch: number, introject: number[]) => {};
        captureSfrCanvasAndAudio: MediaSource //TODO

        introjectionApi: IntrojectionApi
    }
}

type SfrString = number[]

type ActorOutput<T> = {
    output: SfrString;
    newActorState: SfrString;
    newActorHiddenState: T;
    expectedNewSfrState: SfrString;
}

type Command = {
    input: SfrString,
    sfrState: SfrString,
    actorState: SfrString
}

type StateTransition<T> = {
    command: Command;
    actorHiddenState: T;
    out: ActorOutput<T>
    introject: SfrString;
}

type Format = {
    prefix: SfrString;
    sfrStatePrefix: SfrString;
    actorStatePrefix: SfrString;
    suffix: SfrString;
    outputPrefix: SfrString;
}

type Handler<T> = {
    name: string;
    format: Format
    actor: (command: Command, actorHiddenState: T) => ActorOutput<T>
    rewind: (transition: StateTransition<T> | undefined) => void
};

type Maybe<T> = T | undefined

type CommandParserResult = {
    res: Command,
    tail: SfrString
}

type ActorHistory<T> = {
    data: StateTransition<T>[]
}

type Cancellable = number

type ActorCfg = {
    period: number;
    NRetryInvalid: number;
    NRetryNoResponse: number;
}

type IntrojectionApi = {
    subscribe: <T>(handler: Handler<T>, cfg: ActorCfg) => Cancellable
}

const eq = (a: SfrString, b: SfrString): boolean => {
    if (!a || !b) return false
	
	if (a.length != b.length) {
        return false
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false
        }
    }
    return true
}

const findSubStringIndex = (a: SfrString, sub: SfrString): Maybe<number> => {
    for (let i = 0; i < a.length - sub.length; i++) {
        if (eq(sub, a.slice(i, i + sub.length))) {
            return i
        }
    }
    return undefined
}



const parse = (candidate: SfrString, format: Format): Maybe<CommandParserResult> => {
    type Tail = SfrString
    type Result = SfrString

    const parseBetween = (str: SfrString, curPrefix: SfrString, nextPrefix: SfrString): [Result, Tail] | undefined => {
        const j = findSubStringIndex(str, nextPrefix)
		//console.log("str=" + str + " j=" + j)
        return j ? [str.slice(curPrefix.length, j), str.slice(j)] : undefined
    }

    const i = findSubStringIndex(candidate, format.prefix)
	
	if (i === undefined) return undefined
    
    const command = candidate.slice(i)
    
    const parsedInput = parseBetween(command, format.prefix, format.sfrStatePrefix)
	if (!parsedInput) return undefined;
    const [input, tail1] = parsedInput
    
    const parsedSfrState = parseBetween(tail1, format.sfrStatePrefix, format.actorStatePrefix)
    if (!parsedSfrState) return undefined
    const [sfrState, tail2] = parsedSfrState

    const parsedActorState = parseBetween(tail2, format.actorStatePrefix, format.suffix)
    if (!parsedActorState) return undefined
    const [actorState, tail3] = parsedActorState

    return {
        res: {
            input,
            sfrState,
            actorState
        },
        tail: tail3.slice(format.suffix.length)
    }
}



class Subscription<T> {
    public handler: Handler<T>
    public cfg: ActorCfg


    private hist: ActorHistory<T> = { data: [] }
    private invRetryCount = 0;
    private noRespRetryCount = 0;

    public constructor(handler: Handler<T>, cfg: ActorCfg) {
        this.handler = handler;
        this.cfg = cfg
    }

    public inspectHistory(): StateTransition<T>[] {
        return this.hist.data
    }

    public progress(introspect: (ch: number) => number[], inject: (ch: number, introject: number[]) => void): void {
        const memory = introspect(0)

        var cmd: Maybe<Command> = undefined
        var found = parse(memory, this.handler.format)

        while (found != undefined) {
            cmd = found!.res
            found = parse(found!.tail, this.handler.format)
        }

        const prev = this.hist.data[this.hist.data.length - 1]
        if (cmd != undefined) {
            const isValid = !prev || eq(cmd.sfrState, prev.out.expectedNewSfrState) && eq(cmd.actorState, prev.out.newActorState)
            if (isValid) {
                const out = this.handler.actor(
                    cmd, prev?.out.newActorHiddenState
                )

                const introject = [
                    this.handler.format.outputPrefix,
                    out.output,
                    this.handler.format.actorStatePrefix,
                    out.newActorState,
                    this.handler.format.suffix
                ].flat()

                this.hist.data.push({
                    command: cmd,
                    actorHiddenState: prev?.out.newActorHiddenState,
                    out,
                    introject
                })
                inject(0, introject)
            } else {
                if (this.invRetryCount >= this.cfg.NRetryInvalid) {
                    //console.log("rewind invalid state")
					this.invRetryCount = 0
                    this.handler.rewind(this.hist.data.pop())

                } else {
					//console.log("retry invalid state transition")
					this.invRetryCount ++
                    inject(0, prev?.introject ?? [])
                }
            }

        } else {
            if (this.noRespRetryCount >= this.cfg.NRetryNoResponse) {
                //console.log("rewind ignored state")
				this.noRespRetryCount = 0;
                this.handler.rewind(this.hist.data.pop())
            } else {
				//console.log("repeat last state transition")
				this.noRespRetryCount ++
                inject(0, prev?.introject ?? [])
            }
        }

    }

}

const formatFixture = {
    prefix: [1, 2],
    sfrStatePrefix: [5, 6],
    actorStatePrefix: [9, 10],
    suffix: [13, 14],
    outputPrefix: [1, 2],
}

const cfgFixture = {
    period: 2,
    NRetryInvalid: 0,
    NRetryNoResponse: 0
}

const memFixture1 = [1, 2,   3, 4,   5, 6,   7, 8,    9, 10,    11, 12,    13, 14,   15, 16]
const memFixture1Res = [1, 2,   3, 4,  9, 10,    11, 12,    13, 14]

const memFixture2Succ = [1, 2,   3, 4,   5, 6,   7, 8,   9, 10,   11, 12,   13, 14,   15, 16]
const memFixture2SuccRes = [1, 2,   3, 4,   9, 10,   11, 12,   13, 14]


const memFixture2Fail1 = [1, 2,    3, 4,    5, 7,    7, 8,    9, 10,    11, 12,    13, 14,     15, 16]
const memFixture2Fail2 = [1, 2,    3, 4,    5, 6,    7, 8,    9, 10,    11, 15,    13, 14,     15, 16]


const parserTest = () => {
    const candidate = memFixture1


    const expected = {
        res: {
            input: [3, 4],
            sfrState: [7, 8],
            actorState: [11, 12]
        },
        tail: [15, 16]
    }
	const parsed = parse(candidate, formatFixture)
    
	console.assert(eq([1,2,3],[1,2,3]), "eq does not work!")
	console.assert(!eq([1,2,3],[1,2,4]), "homotopies!")
	const ii = findSubStringIndex([1,2,3,4,5,6], [3, 4, 5])
	console.assert(ii, "search does not work: " + ii)
	console.assert(!findSubStringIndex([1,2,3,4,5,6], [6, 6, 6]), "paranoia!")
	
	console.assert(parsed, "parsing failed")
	console.assert(eq(expected.res.input, parsed?.res.input), "input parser failed! " + parsed?.res.input)
	console.assert(eq(expected.res.sfrState, parsed?.res.sfrState), "sfrstate parser failed! " + parsed?.res.sfrState)
	console.assert(eq(expected.res.actorState, parsed?.res.actorState), "actorstate parser failed! " + parsed?.res.actorState)
	console.assert(eq(expected.tail, parsed?.tail), "unexpected tail! " + parsed?.res.tail)
	
}

const subscriptionTest = () => {
    var rewinded = false
    const handler: Handler<any> = {
        name: "test",
        format: formatFixture,
        actor: (command: Command, actorHiddenState: any): ActorOutput<any> => {
            return {
                // repeating same; should not donthat in real
                output: command.input,
                newActorState: command.actorState,
                expectedNewSfrState: command.sfrState,
                newActorHiddenState: actorHiddenState
            }
        },
        rewind: (transition: StateTransition<any> | undefined): void => {
            rewinded = true
        }
    }
    const subscr = new Subscription(handler, cfgFixture)
    var reply1: Maybe<SfrString> = undefined
    subscr.progress(() => memFixture1, (ch, introject) => {
        reply1 = introject
    })
    console.assert(reply1, "reply1 is undefined")
    console.assert(eq(reply1!, memFixture1Res), "wrong reply1: " + reply1)
    console.assert(subscr.inspectHistory().length == 1, "history length! expected 2 got " + subscr.inspectHistory().length)

    var reply2: Maybe<SfrString> = undefined
    subscr.progress(() => memFixture2Succ, (ch, introject) => {
        reply2 = introject
    })
    console.assert(reply2, "reply2 is undefined")
    console.assert(eq(reply2!, memFixture2SuccRes), "wrong reply2: " + reply2)
    console.assert(subscr.inspectHistory().length == 2, "history length! expected 2 got " + subscr.inspectHistory().length)

    var reply3: Maybe<SfrString> = undefined
    subscr.progress(() => memFixture2Fail1, (ch, introject) => {
        reply3 = introject
    })
    console.assert(!reply3, "reply3 is present " + reply3)
    console.assert(subscr.inspectHistory().length == 1, "history length! expected 1 got " + subscr.inspectHistory().length)

    var reply4: Maybe<SfrString>
    subscr.progress(() => memFixture2Fail2, (ch, introject) => {
        reply4 = introject
    })
    console.assert(!reply4, "reply4 is present " + reply4)
    console.assert(subscr.inspectHistory().length == 0, "history is not empty: " + subscr.inspectHistory())


}

//alert('Testing!')
parserTest()
subscriptionTest()



window.introjectionApi = {
    subscribe: <T>(handler: Handler<T>, cfg: ActorCfg) => {
        const subscr = new Subscription<T>(handler, cfg)
        return setInterval(() => subscr.progress(window.introspectRecentMemory, window.injectMemory), cfg.period)
    }
}

      
      //alert("hello")
      /*

protocol

Command(input) from sefirot
<Prefix><input><envstateprefix><envstate><actorstateprefix><actorstate><suffix>


Output from actor (Inserted into Sfr memory):
<RepeatSefirotInput><OutputPrefix><Output><actorstateprefix><actornewstate><suffix>

For prefix:43294, inputs:[584, 13048], results: [5673, 67], env goes from state 6684 to 8909  (predictable to actor) and then to unknown state, actor goes from 99 to 1342 and then to 95

Env state prefix 943
Actor state prefix 789
Suffix 555
Output prefix 666

REWRITES IN SFRT MEMORY

43294584943668478999555
=> 43294584943668478999555666567394389097891342

43294130487891342555 - INVALID ENV STATE TRANSITION (since actor expected 8909)

432941304894389097891342555
=>
4329413048943890978913425556666778995

-
Strings will be catched from recent Sfr memory;
only last match in recent memory will be reported to actor.
valid old state transitions from Sfr memory would be ignored


states are invalid when:
- Sfr does not output proper current state of actor (as known to sfr)
- expected sfr state (not known to sfr)

Actor will retry when state is invalid. 
Actor will retry when no knew command has been received.
(It will keep actor response recent too)

If retries are not successful, actor will start rewinding states.
NRetryInvalid
NRetryNoResponse

After retries actor will rewind it's state.
Note: for side-effectful actors best effort rewind function should be provided
*/
       
    </script>
    
    
    
   
  </body>

</html>