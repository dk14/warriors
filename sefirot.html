<html>
  
  <head>
    <link href='https://fonts.googleapis.com/css?family=Courier Prime' rel='stylesheet'>
    <style>
      body {
        background-color: black;
        font-family: 'Courier Prime';
        
      }
      h1   {color: blue;}
      p    {color: red;}
      
      .slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

button, label, input, textarea {
  font-family: 'Courier Prime';
  background: black; margin:auto;font-size:35px; border: 1px solid green; display: inline-block;padding: 6px 12px;color:green;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}
      
    </style>
  </head>
  
  <body>
    
    <div style="display:block;">
      <button id="request">ACTIVATE</button>
      <font color = "pink"><span id="out"> OBSERVING </span></font>
      <br>
      <br>
        
      
    </div>
    
    <div class="slidecontainer">
      <font color="green">
      Paddle Speed: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSpeed">
      Paddle Gravity: <input type="range" min="1" max="100" value="50" class="slider" id="paddleGravity">
      Paddle Sampling Period: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSampling">
      Paddle Position: <input type="range" min="1" max="100" value="0" class="slider" id="paddlePos">
      Sefirot Output: <input type="range" min="1" max="100" value="0" class="slider" id="sfrOutput">
      </font>
    </div>
    
    <textarea columns="120" rows="7" id="config" style="width:100%;display:none" onchange="window.reconfigure=this.value">
n=1000; //prefixlengthstart
minprefixboundary = 5; 
indiscriminateChoicefullnessBound = 9; 
discriminateChoicefullnessBound = 1000;
sfrAudioChBound = 3
sfrGraphicsChBound = 9
//renderTimeout=5;
//remder=false;
//showCommandLine=false;

    </textarea>
    <br>
    <button id="savemem" >Save Memory</button>
    <button id="loadmem" >Load Memory</button>
    <button id="resetmem" >Reset Memory</button>
    <button id="toggle" onclick="txt=document.getElementById('config');if(txt.style.display=='none')txt.style.display='block'; else txt.style.display='none'">Cfg</button>
    
    <script type="text/javascript" src="https://unpkg.com/butterchurn"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets/lib/butterchurnPresetsExtra.min.js"></script>
  
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js"></script>
    
    <script>
      
      //cd /home
      //python3 -m http.server
      //cat /dev/location > /dev/null &

      // https://www.w3schools.com/howto/howto_js_rangeslider.asp
      
      const channels = 10
      
      const span = document.getElementById("out")
        
      const print = (msg) => {
        span.textContent = msg
      }
      
      var gpu = null 
      var blur = null
      
      var addcircles = null
      
      const width = 1000
      const height = 1000
      
      window.render = true
      
      window.modelExtractionQueue = []
      window.modelExtractionQueueBound = 1000
      
      setInterval(() => {
        modelExtractionQueue.splice(0, -modelExtractionQueueBound)
      }, 10000)
      
      window.modelInjectMemory = (ch, introject) => {
        history[ch].push(...introject)
      }
      
      
      
      try {
        
        window.gpucanvas = document.createElement("canvas");
        gpucanvas.width = 1000
        gpucanvas.height = 1000
        
        const gl =  gpucanvas.getContext('webgl', { preserveDrawingBuffer: true });
        
        
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        gpu = new GPU({
          gpucanvas,
          mode: "webgl",
          context: gl
        });
        
        const n = width
        const m = height
        
        // https://github.com/gpujs/gpu.js/issues/285
        
        blur = gpu.createKernel(function(a, pass, filter) {
                  
              let sum = [0, 0, 0, 0]
              
              
              for (let c = 0; c < 3; c++) {
                for (let i = -pass; i <= pass; i++) {
                  for (let j = -pass; j <= pass; j++) {
                    const value = a[c + 4 * (this.thread.x + i) + 4 * 1000 * (1000 - this.thread.y + j)]
                    if (value / 256 > filter) {
                      sum[c] += value
                    }
                  }
                }
              }
              
              let box = (2 * pass + 1) * (2 * pass + 1)
              
              this.color(sum[0] / (256 * box), sum[1] / (256 * box), sum[2] / (256 * box), 0.9)
              
          }).setOutput([n, m]).setGraphical(true)
        
        
        addcircles = gpu.createKernel(function(n, a, transform, factor) {
          
          
          let x = this.thread.x
          let y = this.thread.y
          
          if (transform !== 0.0) {
            let scalex = 1.0
            let addy = 0.0
            let shiftx = 0.0
            
            let scaley = 1.0
            let addx = 0.0
            let shifty = 0.0
            
  
            if (transform == 1.0) {
              scalex += 0.01 * factor;
            } else if (transform == 2.0) {
              addy += 0.01 * factor;
            } else if (transform == 3.0) {
              shiftx += 0.01 * factor;
            } else if (transform == 4.0) {
              scaley += 0.01 * factor;
            } else if (transform == 5.0) {
              addx += 0.01 * factor;
            } else if (transform == 6.0) {
              shifty += 0.01 * factor; 
            }
            
            x = scalex * this.thread.x + addy * this.thread.y + 1000 * shiftx
            y = scaley * this.thread.y + addx * this.thread.x + 1000 * shifty
            
          }
          
          
          
          for (let i = 0; i < n; i++) {
            const radius = a[i][0]
            const centerx = a[i][1]
            const centery = a[i][2]
            const r = a[i][3]
            const g = a[i][4]
            const b = a[i][5]
            const alpha = a[i][6]
            
            if ((x - centerx)**2 + (y - centery)**2 < radius**2) {
              this.color(r, g, b, alpha)
            } else {
              //this.color(1.0, 1.0, 1.0, 1.0)
            }
          }
          
        }).setOutput([n, m]).setGraphical(true)
        
      } catch (err) {
        console.log(err)
        print(err)
      }
      
      
      
      
      
      const barycentric = (m1, m2, m3, ax = 0.5, ay = 0.15, bx = 0.0, by = 1.0, cx = 1.0, cy = 1.0) => {
        let norm = m1 + m2 + m3
        return [(m1 * ax + m2 * bx + m3 * cx) / norm, (m1 * ay + m2 * by + m3 * cy) / norm]
      }
      
      
      
      const audioElem = new Audio()
      
      window.canvas = window.gpucanvas//document.createElement("canvas");
      canvas.width = 1000
      canvas.height = 1000
      
      window.audioContext = new (window.AudioContext || window.webkitAudioContext) ();
      
        
        
      const streamNode = audioContext.createMediaStreamDestination();
       
      
      var visualizer = null
      
      window.customRenderer = true
      
      window.renderTimeout = 100
      
      const initWinampViz = () => {
         try {
          visualizer = butterchurn.default.createVisualizer(audioContext, canvas, {
            width: 1000,
            height: 1000
          });
          
          // get audioNode from audio source or microphone
          
          
          const mediaSource = audioContext.createMediaStreamSource(streamNode.stream)
          visualizer.connectAudio(mediaSource);
          
          // load a preset
          
          window.presets = butterchurnPresets.getPresets();
          const preset = presets['Flexi, martin + geiss - dedicated to the sherwin maxawow'];
          
          window.presetKeys = Array.from(Object.keys(presets))
          
          //visualizer.loadPreset(preset, 0.0); // 2nd argument is the number of seconds to blend presets
          
          
          
          visualizer.render();
          
        } catch (error) {
          print(error)
        }
      }
      
      if (!customRenderer) {
        initWinampViz()
      }
      
      
      var renderqueue = []
      
      let doBlur = (k, threshold) => {
        try {
          //const imageData = ctx.getImageData(0, 0, 1000, 1000)
          blur(addcircles.getPixels(), k, threshold)
          //ctx.drawImage(blur.canvas, 0, 0)
        } catch (err){
          print(err)
          console.log("blurrerr=" + err)
        }
      }
      
      let doCircle = (cx, cy, r, h, s, l, a, transform, factor) => {
        try {
          
          function hsl2rgb(h,s,l) {
            let a=s*Math.min(l,1-l);
            let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);
            return [f(0),f(8),f(4)];
          }   
          const rgb = hsl2rgb(h, s, l)
          //print(cx)
          addcircles(1, [r, cx, cy, rgb[0], rgb[1], rgb[2], a], transform, factor)
          //ctx.drawImage(window.gpucanvas, 0, 0)
        } catch (err){
          print(err)
          console.log("circleerr=" + err)
        }
      }
      
      if (true) {
        //const ctx = canvas.getContext("2d");
        
        let initRenderState = () => {
          return {
            m1: 1.0,
            m2: 1.0,
            m3: 1.0,
            light: 1.0,
            blurLevel: 1.0,
            hue: 1.0,
            sat: 1.0,
            brush: 1.0,
            alpha: 1.0,
            transform: 0.0,
            transformFactor: 0.0
          }
        }
        
        states = []
        var waited = 0
        
        for (i = 0; i < channels; i++) {
          states.push(initRenderState())
        }
        
        const draw = () => {
          
          
          //ctx.fillStyle = "rgb(0 0 0)";
          //ctx.fillRect(25, 25, 100, 100);
          //ctx.clearRect(45, 45, 60, 60);
          //ctx.strokeRect(50, 50, 50, 50);
          
          if (render && customRenderer && gpu !== null) {
            
            
            
            let toRender = [...renderqueue]
            renderqueue = []
            
            
            for (let el of toRender) {
              const ch = el[0]
              const value = el[1]
              const valueInt = (el[1] * 1000).toFixed(0)
              
              const command = valueInt % 10
              const st = states[ch]
              
              switch (command) {
                case 1: st.m1 = value; break;
                case 2: st.m2 = value; break;
                case 3: st.m3 = value; break;
                case 4: st.light = value; break;
                case 5: st.blurLevel = value; break;
                case 6: st.hue = value; break;
                case 7: st.sat = value; break;
                case 8: st.brush = value; break;
                case 9: st.alpha = value; break;
                case 0: 
                    st.transform = (valueInt / 20) % 6; break
                    if (valueInt / 6 != 0 ) {
                      if ((valueInt / 6) % 2 == 0 && st.transformFactor < 50.0){
                        st.transformFactor += 1.0
                      } else if (st.transformFactor > -50.0) {
                        st.transformFactor -= 1.0
                      }
                    }
                  
                    break;
                default: print("what" + command + "type = " + typeof(el[1]))
              }
              //let fillStyle = `hsl(${((360 * st.hue).toFixed(0) / 10) * 10} ${(100 * st.sat).toFixed(0) * 0 + 100}% ${(10 * st.light + 40).toFixed(0)}% / ${(5 * st.alpha).toFixed(0)}%)`
              //console.log(fillStyle)
              //ctx.fillStyle = fillStyle
              
              const coords = barycentric(st.m1, st.m2, st.m3)
              //ctx.beginPath();
              const base = 10 + st.light * 2
              const radius = Math.pow(2, st.brush * base)
              //ctx.arc(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, 0, 2 * Math.PI);
              //ctx.arc(coords[0] * 1000, coords[1] * 1000, 1000 * st.brush, 0, 2 * Math.PI);
              
              //ctx.fill()
              
              const transform = st.transform 
              const factor = st.transformFactor
              
              doCircle(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, ((360 * st.hue).toFixed(0) / 10) * 10, 1.0, st.light* 0.1 + 0.4, 0.01 + 0.05 * st.alpha, transform, factor)
              
              //print(waited)
              if (waited < renderTimeout) {
                const t0 = performance.now()
                const level = (st.blurLevel * 100)
                if (level > 70) {
                  let filterFactor = 0.1
                  if (level > 80) {
                      filterFactor = 0.4
                  }
                  
                  doBlur(1 + ((6 * (st.blurLevel)).toFixed(0) / 3) * 3, filterFactor * st.sat)
                }
                
                const t1 = performance.now()
                waited = (t1 - t0)
              } else {
                waited -= 1.0
                if (waited < 0) {
                  waited = 0
                }
              }
              
              
            }
            
            doBlur(3, 0.01)
            
          } 
            
          if (visualizer != null) {
            visualizer.render();
          }
          
          
          window.requestAnimationFrame(draw)
        
        }
        try {
          window.requestAnimationFrame(draw)
        } catch (message) {
          print(message)
        }
        
        
      }
      
      var canvasStream = canvas.captureStream()
      
      
      
      const videoElem = document.createElement("video");
      videoElem.srcObject = canvasStream
      
      audioElem.controls = true;
      audioElem.autoplay = false;
      
      videoElem.autoplay = true
      videoElem.controls = true
      
      videoElem.onpause = () => {
        audioElem.pause()
        
      } 
      
      videoElem.onplay = () => {
        audioElem.play()
      }
      window.overrideCanvas = false
      
      videoElem.onvolumechange = () => {
        
        if (visualizer != null && videoElem.muted && !customRenderer) {
          
          
          
          function getRandomInt(max) {
            return Math.floor(Math.random() * max);
          }
          
          if (window.overrideCanvas && getRandomInt(7) == 2) {
            customRenderer = true
            window.winampCanvasStream = videoElem.srcObject
            videoElem.srcObject = canvasStream
            
            print('RUNNING')
          } else {
            const npresets = window.presetKeys.length
            const randomPresetName = window.presetKeys[getRandomInt(npresets)]
            const preset = presets[randomPresetName];
            print(randomPresetName)
            visualizer.loadPreset(preset, 0.0); 
          }
          
         
        
        } else if (videoElem.muted) {
          customRenderer = false
          
          if (window.overrideCanvas == false) {
            window.overrideCanvas = true
          
            window.overridenCanvas = window.canvas
            window.canvas = document.createElement("canvas");
            canvas.width = 1000
            canvas.height = 1000
          
            videoElem.srcObject = canvas.captureStream()
          
            initWinampViz()
          } else {
            videoElem.srcObject = window.winampCanvasStream
          }
          
        }
      }
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(canvas)
      document.body.appendChild(document.createElement("br"))
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(audioElem);
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(videoElem);
      
      
      console.log("666")
      
      
  
      
      
      setTimeout(() => {  
        
        window.oscillatorNode = []
        
        window.reconfigure = ""
        
        window.sfrAudioChBound = 3
        window.sfrGraphicsChBound = 9
        
        window.maxfreq = 120
        window.basefreq = 60
        window.discretisation = 40.0
        
        setInterval(() => {
          (1,eval)(window.reconfigure)
        }, 1000)
        
        
        var history = []
        window.n = 1000
        var m = 10000000
        
        window.showCommandLine=true
        window.commandLine = ""
        const characterSet = "@ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ()/\*+=[]{}#%_~<>!?,.0123456789"
        
        setInterval(() => {
          //let i = ((pos)*100).toFixed(0)
          let i = document.getElementById("sfrOutput").value
          if (i < characterSet.length) {
            const candidate = characterSet[i]
            //print("" + i + " " + candidate)
            if (candidate !== commandLine[commandLine.length-1]) {
              commandLine = commandLine + candidate
            }
            
          } else {
            commandLine = commandLine.slice(0, -1)
            if (commandLine.length == 1) {
              commandLine = ""
            }
          }
          
          if (commandLine.length > 30) {
            commandLine = ""
          }
          const toPrint = commandLine.replace('@', '')
          if (toPrint.length === 0) {
            //print('OBSERVING')
          } else {
            if (showCommandLine) {
              print('>' + toPrint)
              try {
                (1,eval)(toPrint)
              } catch {
                
              }
            }
          }
        }, 10)
        
        const saveState = () => {
          localStorage.setItem('memory', JSON.stringify(history))
        }
        
          
        
        const tryload = () => {
          const stored = localStorage.getItem('memory')
          
          
          if (stored !== null && stored !== "null") {
            //alert(storedCells)
            
            const memory = JSON.parse(stored)
            if (channels === memory.length) {
              history = memory
              console.log(history)
            } else {
              console.log("ignoring history")
            }
            
          } else {
            console.log("mo history found!")
          }
          
        }
        
        
        
        
        
        window.memory = history
        
        setInterval(saveState, 5000)
        
              
        
        const gainNode = audioContext.createGain()
        gainNode.connect(streamNode)
        
        
        const beep = (frequency, i = 0) => {
          //console.log("" + i + "   " + frequency + "  " + gainNode.gain.value)
          
          if (window.oscillatorNode[i]) {
            let delay = 0.05
            
            if (frequency == 0) {
              activeChannells[i] = 0
            } else {
              if (window.oscillatorNode[i].frequency === 0) {
                delay += 0.1
              }
              activeChannells[i] = 1
            }
            
            const activity = activeChannells.reduce((accumulator, current) => accumulator + current, 0);
            
            if (activity > 1) {
              gainNode.gain.setTargetAtTime(1.0 / activity, window.audioContext.currentTime, discretisation / 1000)
            } else {
              gainNode.gain
                .setTargetAtTime(1.0, window.audioContext.currentTime + delay + discretisation * (channels + 1) / 1000, discretisation * (channels + 1) / 1000)
            }
             
            window.oscillatorNode[i]
              .frequency.linearRampToValueAtTime(frequency, 
                window.audioContext.currentTime + discretisation / 1000 + delay)
            //console.log("f" + Math.ceil(frequency, 0))
          }
        }
        
        
        
        const activeChannells = []
        
        
        const initChannells = () => {
          for (i = 0; i < channels; i ++) {
            window.oscillatorNode.push(audioContext.createOscillator())
            window.oscillatorNode[i].type = "sine"
            window.oscillatorNode[i].connect(gainNode);
            history.push([])
            activeChannells.push(0)
            window.oscillatorNode[i].frequency.value = 0
          }
        }
        
        initChannells()
        
        tryload()
        
        
        
        console.log("6669")
        
              
        
        
        
        
        const permission = () => {
          
          //const source = audioContext.createMediaStreamSource(combinedStream);
          audioElem.srcObject = streamNode.stream
          
          //oscillatorNode.connect(audioContext.destination);
          
          for (i = 0; i < channels; i ++) {
            oscillatorNode[i].start();
          }
          
          audioElem.play()
          window.started = true
          
          DeviceMotionEvent.requestPermission()
          print('RUNNING')
          
        }
        
        const btn = document.getElementById( "request" );
        btn.addEventListener( "click", permission );
        
        
        
        
        const loadmem = (event) => {
          navigator.clipboard.readText().then((stateTxt) => {
            try {
               let memory = JSON.parse(atob(stateTxt))
            
              if (channels === memory.length) {
                history = memory
                alert("loaded from clipboard")
              } else {
                alert('LOAD STATE ERROR: WRONG AMOUNT OF CH: ' + memory.length)
              }
              
            } catch (err) {
              alert(err)
              
            }
           
            
          })
          
          
        }
        
        const savemem = () => {
          
          navigator.clipboard.writeText(btoa(JSON.stringify(history)))
          
          alert("saved to clipboard!")
        }
        
        const resetmem = () => {
          history = history.map(x => [])
          alert('reset')
        }
        
        const btn2 = document.getElementById("savemem");
        btn2.addEventListener( "click", savemem );
        
        const btn3 = document.getElementById("loadmem");
        btn3.addEventListener( "click", loadmem);
        
        
        const btn4 = document.getElementById("resetmem");
        btn4.addEventListener( "click", resetmem );
        
        const speedSlider = document.getElementById("paddleSpeed")
        speedSlider.oninput = (e) => {
           window.speed = speedSlider.value / 10
        }
        
        const gravitySlider = document.getElementById("paddleGravity")
        gravitySlider.oninput = () => {
          window.gravity = gravitySlider.value / 100
        }
        
        const samplingSlider = document.getElementById("paddleSampling")
        samplingSlider.oninput = () => {
          clearInterval(window.transitionScheduler)
          window.discretisation = samplingSlider.value / 1.0
          setInterval(window.transition, window.discretisation)
        }
        
        const posSlider = document.getElementById("paddlePos")
        posSlider.oninput = () => {
          window.pos = posSlider.value / 100
        }
        
        const outSlider = document.getElementById("sfrOutput")
        
        
        
        var prev = [0,0,0]
        var energy = 0.001
        
        var energyThreshold = 0.9
        var minEnergy = 0.0
        var energyScale = 1.0
        
        ondevicemotion = (event) => {
          
          var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
          var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
          prev = [x, y, z]
          energy = energyScale * (dx * dx + dy * dy + dz * dz)
          if (energy > energyThreshold || energy < minEnergy) {
            energy = energyThreshold * energyScale
          }
          
        }
        
        //print("999")
        
        window.lag = 5 //5
        window.minprefixboundary = 5
        window.indiscriminateChoicefullnessBound = 9
        window.discriminateChoicefullnessBound = 1000
        
        
        
        function choice(arr){
          
          let unique = new Set(arr)
          let counts = Array.from(unique).map(x => {
            return [x, arr.filter(v => v===x).length]
          }).sort((a, b) => b[1] - a[1])
        
          return counts
            .slice(0, discriminateChoicefullnessBound)
            .pop()[0]
          
          
          //return arr.sort((a,b) =>
            //arr.filter(v => v===b).length - arr.filter(v => v===a).length
          //).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
        
        
        
        let predict = (pattern, history) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0
          const N = history.length - pattern.length - lag
          
          let candidates = []
          for (let i = N-1; i >= 0; i--) {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              candidates.push(history[i + pattern.length])
              if (candidates.length >= indiscriminateChoicefullnessBound) {
                break;
              }
            }
          }
          
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          
          return choice(candidates.slice(0, indiscriminateChoicefullnessBound))
          
        }
        
        
        
        window.speed = 6.0
        window.gravity = 0.6
        const posscale = 1.00
        
        const precision = 1000
        const lim = 1.0
        
        window.pos = 0.0
        var orient = 1.0
        var tick = 0
        var i = 0
        
        window.posThreshold = 0.2
        window.outputThreshold = 2
        
        const inferOutput = (pos, output) => {
          if (output < outputThreshold) {
            return (1.0 - Math.abs(pos)) * precision
          } else {
            if (Math.abs(pos) < posThreshold) {
              return output
            } else {
              return (1.0 - Math.abs(pos)) * precision
            }
          }
        }
        
        
        window.transition = () => {
          
          pos = pos + orient * speed * energy - gravity * pos
          tick += 1
          if (tick % 120 == 0) {
            orient = - orient
          }

          if (pos > lim) {
            pos = lim
            orient = - orient
          }
          
          if (pos < - lim) {
            pos = - lim
            orient = - orient
          }
          
          
          i += 1
          i %= channels
          
          posSlider.value = Math.abs(pos) * 100
            
          history[i].splice(0, history[i].length - m)
          const pattern = history[i].slice(1).slice(-n)
          const prediction = Number.parseFloat(predict(pattern, history[i]))
    
          const output = inferOutput(posscale * pos, prediction) / posscale 
            
          const freq = (basefreq + 
              output * (maxfreq - basefreq) / precision)
              
          if (freq >= maxfreq - 3) {
            beep(0, i)
          } else {
            history[i].push(output.toFixed(0))
            if (i < sfrGraphicsChBound) {
              renderqueue.push([i, output * 1.0 / precision])
            }
              
            modelExtractionQueue.push([i, output * 1.0 / precision])
              
            outSlider.value = output * 100.0 / precision
              
            if (i < sfrAudioChBound) {
              beep(freq, i)
            }
          }
          
        }
        
        window.transitionScheduler = setInterval(transition, discretisation)
      }, 1000)
      

    </script>
    
    <script type="text/javascript" src="https://unpkg.com/ts-browser"></script>

    
    
    <script type="text/typescript">
      //Required window context: modelExtractionQueue: [[]], modelExtractionQueueBound: number, modelInjectMemory: (ch, introject) => {} 
    
      
      declare global {
        interface Window { 
          modelExtractionQueue: [number, number][]; 
          modelExtractionQueueBound: number
          modelInjectMemory: (ch: number, introject: number) => {} 
        }
      }
      
      type Handler = {
        name: string;
      };
      
      //alert("hello")
      
       
    </script>
    
    
    
   
  </body>

</html>