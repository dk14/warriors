<html>
    <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="user-scalable=no, minimal-ui, initial-scale=1.05">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    
    </head>
    <body bgcolor="black">
       <button style="border: 1px solid green; background-color: black; color: green; z-index: 100;"  id="gyro" onclick="console.log('hello'); DeviceMotionEvent.requestPermission()">gyro</button>
        
       
       
       <svg id="cont" style="font-family:'Crafty Girls'; font-size:50px;
      fill:yellow;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
              <defs>

                    <filter id="blurEffect" filterUnits="userSpaceOnUse"
            x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceGraphic" stdDeviation="6" />
                    </filter>

    <filter id="neon"
            x="-100%" y="-100%" width="400%" height="400%">
    <feFlood flood-color="rgb(255,255,128)" flood-opacity="0.5" in="SourceGraphic" />
    <feComposite operator="in" in2="SourceGraphic" />
    <feGaussianBlur stdDeviation="10" />
    <feComponentTransfer result="glow1">
      <feFuncA type="linear" slope="4" intercept="0" />
    </feComponentTransfer>
    <feMerge>
       <feMergeNode in="glow1" />
       <feMergeNode in="SourceGraphic" />
    </feMerge>
  </filter>

<filter
    id="glass-distortion"
            x="-100%" y="-100%" width="400%" height="400%"
  >
    <feTurbulence
      type="fractalNoise"
      baseFrequency="0.01 0.01"
      numOctaves="1"
      seed="5"
      result="turbulence"
    />
    <feDisplacementMap
      in="SourceGraphic"
      in2="turbulence"
      scale="100"
      xChannelSelector="R"
      yChannelSelector="G"
      result="glass"
    />
     <feFlood flood-color="cyan" flood-opacity="0.5" in="glass" />
    <feComposite operator="in" in2="glass" />
    <feGaussianBlur stdDeviation="20" />
    <feComponentTransfer result="glow1">
      <feFuncA type="linear" slope="4" intercept="0" />
    </feComponentTransfer>
    <feMerge>
       <feMergeNode in="glow1" />
       <feMergeNode in="glass" />
    </feMerge>
  </filter>

  <filter id="turbulence-displacement"
        x="-100%" y="-100%" width="400%" height="400%">
   <!-- Source -->
   <feTurbulence type="turbulence"
                 baseFrequency="0.05"
                 numOctaves="2"
                 result="noise" />
   <!-- Combiner -->
   <feDisplacementMap in="SourceGraphic"
                      in2="noise"
                      scale="5"
                      xChannelSelector="R"
                      yChannelSelector="G"
                       />

</filter>

<filter id="turbulence-displacement2"
        x="-100%" y="-100%" width="400%" height="400%">
   <!-- Source -->
   <feTurbulence type="turbulence"
                 baseFrequency="0.04"
                 numOctaves="2"
                 result="noise" />
   <!-- Combiner -->
   <feDisplacementMap in="SourceGraphic"
                      in2="noise"
                      scale="20"
                      xChannelSelector="R"
                      yChannelSelector="G"
                      result="glass" />

    <feFlood flood-color="rgb(255,255,128)" flood-opacity="0.5" in="glass" />
    <feComposite operator="in" in2="glass" />
    <feGaussianBlur stdDeviation="4" />
    <feComponentTransfer result="glow1">
      <feFuncA type="linear" slope="4" intercept="0" />
    </feComponentTransfer>
    <feMerge>
       <feMergeNode in="glow1" />
       <feMergeNode in="glass" />
    </feMerge>
</filter>



                </defs>
                <g id="scene">

                </g>
            
        </svg>
        <script>

            var prevX = 0
            var prevY = 0

            setInterval(() => {
                //energy = 0
            }, 100)

            onmousemove = (event) => {                
                ev = {}
                ev.acceleration = {}
                const x = event.clientX / 1000
                const y = event.clientY / 1000
                ev.acceleration.x = event.clientX - prevX
                ev.acceleration.y = event.clientY - prevY
                ev.acceleration.z = 0
                prevX = x
                prevY = y
                ondevicemotion(ev)
            }

            var prev = [0,0,0]
            var energy = 0.001
            
            var energyThreshold = 0.06
            var minEnergy = 0.0
            var energyScale = 1.0
            
            ondevicemotion = (event) => {
                setInterval(() => {
                    document.getElementById("gyro").style.display = 'none'
                }, 100)
                var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
                var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
                prev = [x, y, z]
                var [x, y, z] = [dx, dy, dz]
                energy = energyScale * (dx * dx + dy * dy + dz * dz)
                if (energy > energyThreshold) {
                    energy = energyThreshold
                }
                
            
            }

            setInterval(() => {
                energy = 0
            }, 300)
        </script>
        <script src="https://unpkg.com/intersects/umd/intersects.min.js"></script>
        <script>
        var screenWidth = document.body.clientWidth - 20
        var screenHeight = document.body.clientHeight - 40

        const rate = 10

         var play = false
         var score = 0
         var highscore = 0
         highscore = localStorage.getItem('highscore') ?? 0
         
         const svgns = "http://www.w3.org/2000/svg"
         const container = document.getElementById( 'cont' ).getElementById( 'scene' );
         document.getElementById( 'cont' ).setAttributeNS(null, "width", screenWidth)
         document.getElementById( 'cont' ).setAttributeNS(null, "height", screenHeight)

         const scoreText = document.createElementNS(svgns, "text");
         scoreText.setAttributeNS(null, 'x', 10);
         scoreText.setAttributeNS(null, 'y', 50);
         scoreText.textContent = "00"
         scoreText.setAttributeNS(null, 'filter', ' url(#neon)')
         container.appendChild(scoreText);

         const retryText = document.createElementNS(svgns, "text");
         retryText.setAttributeNS(null, 'x', screenWidth / 2 - 200);
         retryText.setAttributeNS(null, 'y', screenHeight / 2);
         retryText.setAttributeNS(null, 'style', "fill: yellow");
         retryText.setAttributeNS(null, 'filter', ' url(#neon)')
         
     
         setInterval(() => {
            scoreText.textContent = score
            retryText.textContent = "HIGH SCORE: " + highscore
         }, 200)
         
         const start = () => {
            play = true
            
            while (container.firstChild) {
                container.removeChild(container.lastChild);
            }
            
            try {
                container.appendChild(scoreText);
                container.removeChild(retryText);
            } catch {}
            

            score = 0
            
            
            const initx = screenWidth / 3
            const inity = 300  * screenHeight / 755
            const radius = 30 * screenHeight / 755
            var x = initx
            var y = inity
            

            const circle = document.createElementNS(svgns, 'circle');
            circle.setAttributeNS(null, 'filter', ' url(#glass-distortion)')
            //circle.setAttributeNS(null, 'backdrop-filter', 'blur(3px)')
            circle.setAttributeNS(null, 'cx', x);
            circle.setAttributeNS(null, 'cy', y);
            circle.setAttributeNS(null, 'r', radius * 1.0);
            circle.setAttributeNS(null, 'style', 'fill: yellow; opacity: 1;  stroke: black; stroke-width: 0px;' );
            container.appendChild(circle);

            const rects = []

            const createRect = (x, y, g) => {
                const rect = document.createElementNS(svgns, 'rect');
                const bias = screenHeight * 0.1
                const gate =  Math.max(200, 400 * Math.random()) * screenHeight / 755
                const h = (screenHeight - gate)  * Math.random()

                rect.setAttributeNS(null, 'x', x);
                rect.setAttributeNS(null, 'y', (screenHeight - h));
                rect.setAttributeNS(null, 'width', 50 * screenHeight / 755);
                rect.setAttributeNS(null, 'height', h);
                rect.setAttributeNS(null, 'style', 'fill: black; opacity: 0.2; stroke: pink; stroke-width: 10px; ' );
                //rect.setAttributeNS(null, 'filter', ' url(#turbulence-displacement2)')
                //rect.setAttributeNS(null, 'filter', ' url(#neon)')
                g.appendChild(rect);
                rects.push(rect)

                
                const rect2 = document.createElementNS(svgns, 'rect');
                rect2.setAttributeNS(null, 'x', x);
                rect2.setAttributeNS(null, 'y', 0);
                rect2.setAttributeNS(null, 'width', 50 * screenHeight / 755);
                rect2.setAttributeNS(null, 'height', ((screenHeight - h) - gate));
                rect2.setAttributeNS(null, 'style', 'fill: black; opacity: 0.2; stroke: cyan; stroke-width: 10px;' );
                //rect2.setAttributeNS(null, 'filter', ' url(#turbulence-displacement2)')
                //rect2.setAttributeNS(null, 'filter', ' url(#neon)')

                g.appendChild(rect2);
                rects.push(rect2)

                container.removeChild(scoreText);
                container.appendChild(scoreText);
            }

            var i = 0

            const blocks = document.createElementNS(svgns, 'g');
            container.appendChild(blocks);
            //blocks.setAttributeNS(null, 'filter', ' url(#turbulence-displacement)')
            
            const cancel2 = setInterval(() => {

                i++


                
                const gravity = ((6 + 5 * y / screenHeight) * screenHeight / 755) / rate
                const shift = (y - (energy * energy * 15000 * (screenHeight / 755) * (screenHeight / 755)) / rate)
                y1 = Math.max(0, Math.min(screenHeight, (shift + gravity)))
                if (y1 < 30) {
                    y1 = screenHeight
                }
                if (y1 < y) {
                    y = y1 
                } else {
                    y = y1 + gravity * (0.3 * 1000 / shift)
                }
                circle.setAttributeNS(null, 'cx', x);
                circle.setAttributeNS(null, 'cy', y); 

             }, 100 / rate)

            const cancel3 = setInterval(() => {

                if (i % 250 === 0) {
                    createRect(screenWidth - 100 + i, screenHeight - 200 + 30, blocks)
                }

                const translate = - 0.8 * i

                blocks.setAttributeNS(null, "transform", `translate(${translate}, 0)`)
                
            }, 200 / rate)

            const cancel4 = setInterval(() => {
                const translate = - 0.8 * i
                rects.forEach(r => {
                                
                    const rcx =  parseInt(r.getAttributeNS(null, 'x')) + translate

                    r.setAttributeNS(null, 'x', parseInt(r.getAttributeNS(null, 'x')) - 1)

                    if (rcx < - 50 * screenHeight / 755) {
                        blocks.removeChild(r)
                        rects.splice(rects.findIndex(x => x === r), 1)
                    }

                    const rectEdge = rcx
                    
                    if (x > rectEdge + 30 && r["counted"] !== true) {
                        r["counted"] = true
                        score += 5
                    }

                    const lost = Intersects.circleBox(x, y, radius, rcx, parseInt(r.getAttributeNS(null, 'y')), parseInt(r.getAttributeNS(null, 'width')), parseInt(r.getAttributeNS(null, 'height')))
                    if (lost) {
                        clearInterval(cancel2)
                        clearInterval(cancel3)
                        clearInterval(cancel4)
                        play = false
                        if (score > highscore) {
                            highscore = score
                            localStorage.setItem('highscore', highscore)
                        }
                        container.appendChild(retryText);
                    }

                })

            }, 1000 / rate)
         }
         start()
         document.addEventListener("touchend", () => {
            if (!play) {
               start()
            }
         });
         window.onclick = () => {
            if (!play) {
               start()
            }
         }


        </script>
    </body>
</html>