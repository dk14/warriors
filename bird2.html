<html>
    <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="user-scalable=no, minimal-ui, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" href="./favicon.png">
     <title>Sunspot</title>
    </head>
    <body bgcolor="black">
       <button style="border: 3px solid green; background-color: black; color: green; z-index: 100; font-size: 40px;"  id="gyro" onclick="console.log('hello'); DeviceMotionEvent.requestPermission()">GYRO</button>
        
       <canvas id="canvas" style="position: absolute; top: 0; left: 0; z-index:-20">

       </canvas>
       
       <svg id="cont" style="font-family:'Crafty Girls'; font-size:50px;
      fill:yellow; position: absolute; top: 0; left: 0; z-index:-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <g id="scene">

            </g>
            
        </svg>
        <script>

            try {
               navigator.wakeLock.request();
            } catch {

            }
            

            var before,now;
            before=Date.now();
            const fpshist = []
            window.fps=60;
            requestAnimationFrame(
                function loop(){
                    now=Date.now();

                    fpshist.push(Math.round(1000/(now-before)))
                    fpshist.splice(0, fpshist.length - 10)

                    if (fpshist.length > 3) {
                        const fpsprecise=fpshist.reduce((a, b) => a + b) / fpshist.length

                        if (fpsprecise < 5) {
                            window.fps=3;
                        } else if (fpsprecise < 10) {
                            window.fps=7;
                        } else if (fpsprecise < 20) {
                            window.fps=15;
                        } else if (fpsprecise < 50) {
                            window.fps=30;
                        } else {
                            window.fps=60;
                        }

                        //window.fps = 10 * Math.round(100/(now-before));
                    }
                    
                    before=now;
                    requestAnimationFrame(loop);
                }
            );

            window.canvas = document.getElementById("canvas")
            const context = canvas.getContext('2d');

            canvas.width = document.body.clientWidth - 20
            canvas.height = document.body.clientHeight - 40
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const canvasStream = canvas.captureStream()
      
      
      
            const videoElem = document.createElement("video");
            videoElem.srcObject = canvasStream
            
            videoElem.autoplay = true
            videoElem.controls = true
            videoElem.style.display = "none"



            const fullscreen = document.createElement("button");
      
            fullscreen.style = "border: none;opacity: 0.2; position: absolute; left: 10px; bottom: 10px; background-color: black; color: cyan; z-index: 200; font-size: 60px;"
            
            fullscreen.innerText = "â›¶"

            fullscreen.addEventListener("touchend", () => {
               fullscreen.onclick()
            });
            fullscreen.onclick = () => {
                if (videoElem.style.display === 'none') {
                    videoElem.style.display = "block"
                    videoElem.play()
                    if (videoElem.requestFullscreen) {
                        videoElem.requestFullscreen();
                    } else if (videoElem.webkitRequestFullscreen)  {
                        videoElem.webkitRequestFullscreen();
                    } else if (videoElem.msRequestFullScreen) {
                        videoElem.msRequestFullScreen();
                    }
                } else {
                    videoElem.style.display = "none"
                }
                
               
            }

            document.body.appendChild(videoElem)
            document.body.appendChild(fullscreen)



            const drawVingette = () => {
                context.beginPath();
                
                
                const gradient = context.createRadialGradient(canvas.width / 2,  canvas.height / 2, canvas.width , canvas.width / 2, canvas.height / 2, 0);
                gradient.addColorStop(0, `hsla(200, 100%, 50%, 0.0)`);
                gradient.addColorStop(1,  `hsla(200, 100%, 50%, 0.17)`);

                context.fillStyle = gradient
                context.arc(canvas.width / 2, canvas.height / 2, canvas.width * 2, 0, 2 * Math.PI, true);
                context.fill();

                context.globalCompositeOperation = "lighter";
                const gradient2 = context.createRadialGradient(canvas.width / 2,  canvas.height / 2, canvas.width * 2 , canvas.width / 2, canvas.height / 2, 0);
                gradient.addColorStop(0, `hsla(200, 100%, 50%, 0.0)`);
                gradient.addColorStop(1,  `hsla(200, 100%, 50%, 0.1)`);
                context.fillStyle = gradient2
                context.arc(canvas.width / 2, canvas.height / 2, 0, 0, 2 * Math.PI, true);
                context.fill();
            }


            const drawCircle = (x, y, r, c, op) => {
                context.beginPath();
                
                
                const gradient = context.createRadialGradient(x * canvas.width,  y * canvas.height, 0, x * canvas.width, y * canvas.height, r * 2 * canvas.height);
                gradient.addColorStop(0, `hsla(${c * 360}, 100%, 50%, 0.5)`);
                gradient.addColorStop(1,  `hsla(${c * 360}, 100%, 50%, 0)`);
                context.globalCompositeOperation = "lighter";
                context.fillStyle = gradient;
                context.arc(x * canvas.width, y * canvas.height, r * 2 * canvas.height, 0, 2 * Math.PI, true);
                context.fill();

                context.globalCompositeOperation = "darken";
                 context.fillStyle = `hsla(0, 0%, 0%, ${1 - op})`
                context.arc(x * canvas.width, y * canvas.height, r * 2 * canvas.height, 0, 2 * Math.PI, true);
                context.fill();
            }

            //drawCircle(0.5, 0.5, 0.2, 0.5, 1.0)
            //drawCircle(0.5, 0.5, 0.2, 0.5, 0.05)

        </script>
        <script>

            var prevX = 0
            var prevY = 0

            onmousemove = (event) => {                
                ev = {}
                ev.acceleration = {}
                const x = event.clientX / 1000
                const y = event.clientY / 1000
                ev.acceleration.x = event.clientX - prevX
                ev.acceleration.y = event.clientY - prevY
                ev.acceleration.z = 0
                prevX = x
                prevY = y
                ondevicemotion(ev, true)
            }

            var prev = [0,0,0]
            var energy = 0.001
            
            var energyThreshold = 0.06
            var minEnergy = 0.0
            var energyScale = 1.0
            
            ondevicemotion = (event, mouse = false) => {
                setInterval(() => {
                    document.getElementById("gyro").style.display = 'none'
                }, 100)
                var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
                var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
                prev = [x, y, z]
                var [x, y, z] = [dx, dy, dz]
                energy = energyScale * (dx * dx + dy * dy + dz * dz)
                if (energy > energyThreshold) {
                    energy = energyThreshold
                }

                if (mouse !== true) {
                    energy *= 1.3
                }
                
            
            }

            setInterval(() => {
                energy = 0
            }, 300)
        </script>
        <script src="https://unpkg.com/intersects/umd/intersects.min.js"></script>
        <script>
        var screenWidth = document.body.clientWidth - 20
        var screenHeight = document.body.clientHeight - 40


         var play = false
         var score = 0
         var highscore = 0
         highscore = localStorage.getItem('highscore') ?? 0
         
         const svgns = "http://www.w3.org/2000/svg"
         const container = document.getElementById( 'cont' ).getElementById( 'scene' );
         document.getElementById( 'cont' ).setAttributeNS(null, "width", screenWidth)
         document.getElementById( 'cont' ).setAttributeNS(null, "height", screenHeight)

         const scoreText = document.createElementNS(svgns, "text");
         scoreText.setAttributeNS(null, 'x', 30);
         scoreText.setAttributeNS(null, 'y', 88);
         scoreText.textContent = "00"
         scoreText.setAttributeNS(null, 'style', "fill: cyan; font-size: 80px; font-style: italic; opacity: 0.3;");
     
         container.appendChild(scoreText);

         const retryText = document.createElementNS(svgns, "text");
         retryText.setAttributeNS(null, 'x', screenWidth / 2 - 200);
         retryText.setAttributeNS(null, 'y', screenHeight / 2);
         retryText.setAttributeNS(null, 'style', "fill: lightgreen;font-size: 30px;font-style: italic; font-weight:bolder; opacity: 0.5");
         
         const retryRect = document.createElementNS(svgns, "rect");

         retryRect.setAttributeNS(null, 'x', 0);
         retryRect.setAttributeNS(null, 'y', 0);
         retryRect.setAttributeNS(null, 'width', screenWidth);
         retryRect.setAttributeNS(null, 'height', screenHeight);
         retryRect.setAttributeNS(null, 'style', "fill: black; opacity: 0.5");
     
         setInterval(() => {
            scoreText.textContent = score
            retryText.textContent = "HIGH SCORE: " + highscore
            retryText.setAttributeNS(null, 'x', screenWidth / 2 - retryText.getBoundingClientRect().width / 2);
            retryText.setAttributeNS(null, 'y', screenHeight / 2);
         }, 200)
         
         const start = () => {
            fullscreen.style.display = 'none'
            play = true
            
            while (container.firstChild) {
                container.removeChild(container.lastChild);
            }
            
            try {
                container.appendChild(scoreText);
                container.removeChild(retryText);
            } catch {}
            
            score = 0
            const initx = screenWidth / 3
            const inity = 300  * screenHeight / 755
            const radius = 30 * screenHeight / 755
            var x = initx
            var y = inity

            const drawings = []

            const createCircle = () => {

                const circle = {
                    type: 'circle'
                }

                circle.cx = x
                circle.cy = y
                circle.dcx = 0
                circle.dcy = 0
                circle.r = radius * 1.3 * 755 / screenHeight;
            
                circle.opacity = 0.5

                circle.blend = "lighter";
                
                circle.fill = "gradient"

                drawings.push(circle)
                return circle

            }

            const circle = createCircle()

            const circles = []

            for (let ii = 0; ii < 10; ii++) {
                circles.push(createCircle())
            }

            const rects = []

            const draw = () => {
                context.clearRect(0, 0, screenWidth, screenHeight)
                
                if (videoElem.style.display === 'block') {
                    context.fillStyle = `black`
                    context.beginPath();
                    context.rect(0, 0, screenWidth, screenHeight);
                    context.fill()
                }

                drawVingette()
                if (score % 150 > 60) {
                   //drawCircle(0.5, 0.5, 1.0, 0.2 + 0.5 * ((100 * y / screenHeight) % 10) / 100., 0.8)
                    //drawCircle(0.5, 0.5 * ((100 * y / screenHeight) % 30) / 100, 1.0, 0.2 + 0.5 * ((100 * y / screenHeight) % 30) / 100., 0.8)
                } else {
                    
                }
                
                drawings.forEach(d => {
                    context.globalCompositeOperation = d.blend ?? "source-over"
                    if (d.opacity !== undefined) {
                        if (d.stroke) {
                            d.stroke[3] = d.opacity
                        }
                        if (d.fill !== "gradient") {
                            d.fill[3] = d.opacity
                        }
                        
                    }
                   
                    if (d.type === 'rect') {
                        context.fillStyle = `rgba(${d.fill[0]}, ${d.fill[1]}, ${d.fill[2]}, ${d.fill[3]})`
                        

                        context.lineWidth = d.strokeWidth ?? 0;
                        context.beginPath();
                        context.rect(d.x + (d.dx ?? 0), d.y + (d.dy ?? 0), d.width, d.height);
                        
                        context.fill();
                        if (d.strokeWidth) {
                            context.strokeStyle = `rgba(${d.stroke[0]}, ${d.stroke[1]}, ${d.stroke[2]}, ${d.stroke[3]})`
                            context.stroke();
                        }
                        
                    } else if (d.type === 'circle') {
                        if (d.fill === 'gradient') {
                            const gradient = context.createRadialGradient(d.cx + (d.dcx ?? 0),  d.cy + (d.dcy ?? 0), 0, d.cx + (d.dcx ?? 0), d.cy + (d.dcy ?? 0), d.r);
                            gradient.addColorStop(0, `rgba(228,228,0,${1.0 * d.opacity})`);
                            gradient.addColorStop(0.95,  `rgba(0,30,0,${0.05 * d.opacity})`);
                            gradient.addColorStop(1,  `rgba(220,220,0,0`);
                            context.fillStyle = gradient
                        } else {
                            context.fillStyle = `rgba(${d.fill[0]}, ${d.fill[1]}, ${d.fill[2]}, ${d.fill[3]})`
                        }
                        
                        
                        context.lineWidth = d.strokeWidth ?? 0;
                        context.beginPath();
                        context.arc(d.cx + (d.dcx ?? 0), d.cy + (d.dcy ?? 0), d.r * 2, 0, 2 * Math.PI, true);
                        
                        context.fill();

                        if (d.strokeWidth) {
                            context.strokeStyle = `rgba(${d.stroke[0]}, ${d.stroke[1]}, ${d.stroke[2]}, ${d.stroke[3]})`
                            context.stroke();
                        }
                    }
                })
                requestAnimationFrame(draw)

            }
            draw()



            const createRect = (x, y, id) => {

                const bias = screenHeight * 0.1
                const gate =  Math.max(200, 400 * Math.random()) * screenHeight / 755
                const h = (screenHeight - gate)  * Math.random()

                const rect = {
                    type: 'rect'
                }
                rect.x = x
                rect.y = screenHeight - h
                rect.width = 50 * screenHeight / 755
                rect.height = h
                rect.fill = [0,0,0,1.0]
                rect.stroke = [255, 192, 203, 1.0]
                rect.opacity = 0.0
                rect.strokeWidth = 10
                rect.id = id + "1"

                drawings.push(rect)
                rects.push(rect)

                
                const rect2 = {
                    type: 'rect'
                }

                rect2.x = x
                rect2.y = 0

                rect2.width = 50 * screenHeight / 755
                rect2.height =  ((screenHeight - h) - gate)
                rect2.fill = [0,0,0,1.0]
                rect2.stroke = [0, 255, 255, 1.0]
                rect2.strokeWidth = 10
                rect2.opacity = 0.0
                rect2.id = id + "2"

                rects.push(rect2)
                drawings.push(rect2)

                container.removeChild(scoreText);
                container.appendChild(scoreText);
            }


            window.i = 0
            const speed = 1.0
            var time = performance.now()

            const loop = setInterval(() => {

                const delta = Math.round((performance.now().toFixed() - time) / 10)
                window.i += delta
                time = performance.now()

                const gravity = ((7 + 7 * y / screenHeight) * screenHeight / 755) / 10
                const shift = (y - (delta * energy * energy * 15000) / 10)
                y1 = Math.max(0, Math.min(screenHeight, (shift + gravity)))
                if (y1 < 30) {
                    y1 = screenHeight
                }
                if (y1 < y) {
                    y = y1 
                } else {
                    y = y1 + gravity * (0.3 * 1000 / shift)
                }
                circle.cx = x;
                circle.cy = y;

                circles.forEach((c, ii) => {
                     const cx = c.cx
                    const cy = c.cy
                    const dx =  10 * (1 + 5 * energy + 0.1 * (screenHeight - y) / y) * (screenHeight / 755)  * (Math.sin(ii % 7 + i / 90 + 0.01 * cy) + Math.sin(90 - 0.01 * cy + 0.0001 * cx * c.dcy + (y % 20) / 60))
                    const dy = 15 * (1 + 10 * energy) * (screenHeight / 755)  * (Math.cos(ii % 5 + i / (20 + 20 * energy) + energy) + Math.sin(30 + 0.00001 * cx * c.dcy + i / 100 + (y % 20) / 60) + Math.sin(0.1 * (y * y % 20) / 10));  
                    c.dcx = dx
                    c.dcy = dy
                    c.cy = y
                    c.r = radius + 9 + 500 * energy * energy + 0.1 * (screenHeight - y) / y + 5 *  Math.sin(0.1 * (c.dcy % (1 + 40 * energy)) / 10 + 10 * energy)

                })

                if (i % 200 < 10 && rects.length < 12 && !rects.find(r => r.x > screenWidth + i - 10)) {
                    createRect(screenWidth + i, screenHeight - 200 + 30, i)
                }

 

                rects.forEach((r, ii) => {

                    r.dx = - speed * i
                                
                    const rcx = r.x + (r.dx ?? 0)

                    const edge =  r.y + (r.dy ?? 0) < 30 ? r.height : r.y + (r.dy ?? 0)
                    r.opacity = 0.15 - (y - edge) / (5 * screenHeight) - 0.2 * Math.abs((rcx - x) / screenHeight)

                    
                    if (rcx < -50) {
                        rects.splice(rects.findIndex(x => x.id === r.id), 1)
                        drawings.splice(drawings.findIndex(x => x.id === r.id), 1)
 
                    }

                    const rectEdge = rcx
                    
                    if (x > rectEdge + 30 && r["counted"] !== true) {
                        r["counted"] = true
                        score += 5
                    }

                    const lost = Intersects.circleBox(x, y, radius, rcx, r.y + (r.dy ?? 0), r.width, r.height)
                    if (lost) {
                        clearInterval(loop)
                        rects.length = 0
                        play = false
                        if (score > highscore) {
                            highscore = score
                            localStorage.setItem('highscore', highscore)
                        }
                        
                        container.appendChild(retryRect);
                        container.appendChild(retryText);
                        fullscreen.style.display = 'block'
                        setTimeout(() => {
                            if (!play && videoElem.style.display === 'block') {
                                start()
                            }
                        }, 1000)
                    }

                })

            }, 10)
         }
         start()
         document.addEventListener("touchend", () => {
            if (!play) {
               start()
            }
         });
         window.onclick = () => {
            if (!play) {
               start()
            }
         }


        </script>
    </body>
</html>