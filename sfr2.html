<html>
    <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="user-scalable=no, minimal-ui, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" href="./favicon.png">
     <title>Sunspot</title>
    </head>
    <body bgcolor="black">
       <button style="border: 3px solid green; background-color: black; color: green; z-index: 100; font-size: 40px;"  id="gyro" onclick="console.log('hello'); DeviceMotionEvent.requestPermission()">GYRO</button>
      
       <div id="debug"></div>
        
       <canvas id="canvas" style="display:block; position: fixed; top: 0; left: 0; z-index:-30"></canvas>
        <canvas id="preview" style="display:block; position: fixed; top: 0; left: 0; z-index:-20"></canvas>
      


       </canvas>

        <script>
            try {
               navigator.wakeLock.request();
            } catch {

            }
            
            var before,now;
            before=Date.now();
            const fpshist = []
            window.fps=60;
            requestAnimationFrame(
                function loop(){
                    now=Date.now();

                    fpshist.push(Math.round(1000/(now-before)))
                    fpshist.splice(0, fpshist.length - 10)

                    if (fpshist.length > 8) {
                        const fpsprecise=fpshist.reduce((a, b) => a + b) / fpshist.length

                        if (fpsprecise < 5) {
                            window.fps=3;
                        } else if (fpsprecise < 10) {
                            window.fps=7;
                        } else if (fpsprecise < 20) {
                            window.fps=15;
                        } else if (fpsprecise < 50) {
                            window.fps=30;
                        } else {
                            window.fps=60;
                        }
                    }
                    
                    before = now;
                    requestAnimationFrame(loop);
                }
            );

        </script>
        <script>

            var prevX = 0
            var prevY = 0

            onmousemove = (event) => {                
                ev = {}
                ev.acceleration = {}
                const x = event.clientX / 1000
                const y = event.clientY / 1000
                ev.acceleration.x = event.clientX - prevX
                ev.acceleration.y = event.clientY - prevY
                ev.acceleration.z = 0
                prevX = x
                prevY = y
                ondevicemotion(ev, true)
            }

            var prev = [0,0,0]
            var energy = 0.001
            
            var energyThreshold = 0.06
            var minEnergy = 0.0
            var energyScale = 1.0
            
            ondevicemotion = (event, mouse = false) => {
                setInterval(() => {
                    document.getElementById("gyro").style.display = 'none'
                }, 100)
                var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
                var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
                prev = [x, y, z]
                var [x, y, z] = [dx, dy, dz]
                energy = energyScale * (dx * dx + dy * dy + dz * dz)
                if (energy > energyThreshold) {
                    energy = energyThreshold
                }

                if (mouse !== true) {
                    energy *= 1.3
                }
                
            
            }

            setInterval(() => {
                energy = 0
            }, 300)
        </script>
        <script>

            window.$ = (el) => {
                return document.getElementById(el)
            }

            

            const screenWidth = document.body.clientWidth - 20
            const screenHeight = document.body.clientHeight - 40

            window.canvas = document.getElementById("canvas")
            const context = canvas.getContext('2d');
            canvas.width = document.body.clientWidth - 20
            canvas.height = document.body.clientHeight - 40

            window.previewCanvas = document.getElementById("preview")
            const previewContext = previewCanvas.getContext('2d');
            previewCanvas.width = document.body.clientWidth - 20
            previewCanvas.height = document.body.clientHeight - 40

            window.i = 0
            window.y = 0
            const speed = 60.0
            var time = performance.now()

            const numerals = [100,200,300,400,500,600,700, 800, 900, 1000, 1100].map(x => x / 10)
            const alphabet = ["_"].concat(numerals).concat(["_"])
            const console = []
            var maxcursor = 0

            const maxnum = Math.max(...numerals)
            const maxangle = maxnum

            const acceptanceThreshold = 3

            const state = {
                command: 0,
                circle_radius: 0,
                circle_color: 0,
                line_angle: 0, 
                line_length: 0, 
                line_thickness: 0, 
                line_color: 0,
                center: [screenWidth / 2, screenHeight / 2],
                debug: {}
            }

            const commands = ["circle_radius", "circle_color", "line_angle", "line_length", "line_thickness", "line_color"]

            const getPolarGradient = (c, cx, cy, r, where) => {
                const gradient = where.createRadialGradient(cx,  cy, 0, cx, cy, r);
                gradient.addColorStop(0, `hsla(${c}, 100%, 50%, 0.5)`);
                gradient.addColorStop(1,  `hsla(${c}, 100%, 0%, 0.0)`);
                return gradient
            }

            const getLinearGradient = (c, x1, y1, x2, y2, where) => {
                const gradient = where.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, `hsla(${c}, 100%, 50%, 0.5)`);
                gradient.addColorStop(1,  `hsla(${c}, 100%, 0%, 0.0)`);
                return gradient
            }

            const drawCircle = (cx, cy, r, c, where) => {
                where.beginPath();

                state.debug.cicrle = {}
                state.debug.cicrle.cx = cx
                state.debug.cicrle.cy = cy
                state.debug.cicrle.r = r
                state.debug.cicrle.c = c
                const radiusThreshold = 100

                if (r > radiusThreshold) {
                    
                    where.globalCompositeOperation = "lighter";
                    where.fillStyle = getPolarGradient(c, cx, cy, r - radiusThreshold, where);
                    where.arc(cx, cy, r - radiusThreshold, 0, 2 * Math.PI, true);
                    where.fill();

                } else {
                    where.globalCompositeOperation = "lighten";
                    where.fillStyle = getPolarGradient(c, cx, cy, radiusThreshold - r, where);
                    where.arc(cx, cy, radiusThreshold - r, 0, 2 * Math.PI, true);
                    where.fill();

                    where.globalCompositeOperation = "difference"
                    where.fillStyle = getPolarGradient(c, cx, cy, radiusThreshold - r, where);
                    where.arc(cx, cy, radiusThreshold - r, 0, 2 * Math.PI, true);
                    where.fill();
                }

            }

            const drawLine = (cx, cy, angle, length, thickness, c, where) => {
                where.translate(cx, cy);
                where.rotate(angle * 2 * Math.PI / maxangle);

                const thicknessPx = 5 * thickness / maxnum

        
                where.fillStyle = getLinearGradient(c, -thicknessPx / 2, 0, thicknessPx, length, where)
                where.fillRect(-thicknessPx / 2, 0, thicknessPx, length); // Draw the rectangle

                where.setTransform(1, 0, 0, 1, 0, 0);
            }

            const updateState = (state, input) => {
                actions = [
                    () => state.circle_radius = input,
                    () => state.circle_color += input,
                    () => state.line_angle += input,
                    () => state.line_length = input,
                    () => state.line_thickness = input,
                    () => state.line_color = input,
                ]
                actions[state.command]()
            }

            const previewCircleColor = 20
            const previewLineLength = 10
            const previewLineThickness = 2
            const previewLineColor = 20

            const previewCommand = (state, input) => {
                previewContext.clearRect(0,0, screenWidth, screenHeight)
                actions = [
                    () => {
                        drawCircle(state.center[0], state.center[1], input, previewCircleColor, previewContext)
                    },
                    () => {
                        drawCircle(state.center[0], state.center[1], state.circle_radius, input, previewContext)
                    },
                    () => {
                        drawLine(state.center[0], state.center[1], input, previewLineLength, previewLineThickness, previewLineColor, previewContext)
                    },
                    () => {
                        drawLine(state.center[0], state.center[1], state.line_angle, input, previewLineThickness, previewLineColor, previewContext) 
                    },
                    () => {
                        drawLine(state.center[0], state.center[1], state.line_angle, state.line_length, input, previewLineColor, previewContext)

                    },
                    () => {
                        drawLine(state.center[0], state.center[1], state.line_angle, state.line_length, state.line_thickness, input, previewContext)
                    },
                ]
                actions[state.command]()
                
            }

            const sin = Math.sin
            const cos = Math.cos

            const executeCommand = (state, input) => {
                
                updateState(state, input)

                if (state.center[0] > screenWidth 
                    || state.center[0] < 0
                    || state.center[1] > screenHeight
                    || state.center[1] < 0) {
                    
                    state.center = [screenWidth / 2, screenHeight / 2]
                }
                //check if state has enough info to render a circle or a line
                // render either a circle or a line on main canvas
                if (state.command === 1) {
                    drawCircle(state.center[0], state.center[1], state.circle_radius, input, context)
                } else if (state.command === 5) {
                    drawLine(state.center[0], state.center[1], state.line_angle, state.line_length, state.line_thickness, input, context)
                    state.center = [state.center[0] + state.line_length * sin(state.line_angle * 2 * Math.PI / maxangle), state.center[0] + state.line_length * cos(state.line_angle * 2 * Math.PI / maxangle)]
                }
               
                state.command = (state.command + 1) % commands.length
            }

           
            const loop = setInterval(() => {
                $('debug').innerHTML = `<pre><font color='green'>state: ${JSON.stringify(state, null, 2)}</font></pre>`

                const delta = Math.round((performance.now().toFixed() - time) / 10)
                window.i += delta
                time = performance.now()

                const gravity = speed * ((6 + 5 * y / screenHeight) * screenHeight / 755) / 10
                const shift = (y - (speed * energy * energy * 15000 * (screenHeight / 755) * (screenHeight / 755)) / 10)
                y1 = Math.max(0, Math.min(screenHeight, (shift + gravity)))
                if (y1 < 30) {
                    y1 = screenHeight
                }

                if (y1 < y) {
                    y = y1 
                } else {
                    y = y1 + gravity * (0.3 * 1000 / shift)
                }

                if (y > screenHeight) {
                    y = screenHeight
                }

                const cursor = Math.round(alphabet.length * (screenHeight - y) / screenHeight)

                if (cursor > maxcursor) {
                    maxcursor = Math.min(cursor, alphabet.length - 1)
                }

                state.debug.y = y
                state.debug.cursor = cursor
                state.debug.maxcursor = maxcursor
                state.debug.current = alphabet[maxcursor]
                

                if (alphabet[maxcursor] !== '_') {
                    if (maxcursor - cursor > acceptanceThreshold || (cursor === 0 && maxcursor !== 0)) {
                        executeCommand(state,  alphabet[maxcursor])
                        console.push(alphabet[maxcursor])
                        y = screenHeight
                        
                    } else {
                        previewCommand(state,  alphabet[maxcursor])
                    }
                }

                if (cursor === 0) {
                    maxcursor = 0
                }
                

                //TODO revert state

            }, 10)
        </script>
    </body>
</html>