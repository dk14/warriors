<html>
  
  <head>
    <link href='https://fonts.googleapis.com/css?family=Courier Prime' rel='stylesheet'>
    <style>
      body {
        background-color: black;
        font-family: 'Courier Prime';
        
      }
      h1   {color: blue;}
      p    {color: red;}
      
      .slidecontainer {
  width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
  -webkit-appearance: none;  /* Override default CSS styles */
  appearance: none;
  width: 100%; /* Full-width */
  height: 25px; /* Specified height */
  background: #d3d3d3; /* Grey background */
  outline: none; /* Remove outline */
  opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
  -webkit-transition: .2s; /* 0.2 seconds transition on hover */
  transition: opacity .2s;
}

button, label, input, textarea {
  font-family: 'Courier Prime';
  background: black; margin:auto;font-size:35px; border: 1px solid green; display: inline-block;padding: 6px 12px;color:green;
}

/* Mouse-over effects */
.slider:hover {
  opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none; /* Override default look */
  appearance: none;
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
  width: 25px; /* Set a specific slider handle width */
  height: 25px; /* Slider handle height */
  background: #04AA6D; /* Green background */
  cursor: pointer; /* Cursor on hover */
}
      
    </style>
  </head>
  
  <body>
    
    <div style="display:block;">
      <button id="request">AWAKE IT</button>
      <font color = "pink"><span id="out"> OBSERVING </span></font>
      <br>
      <br>
        
      
    </div>
    
    <div class="slidecontainer">
      <font color="green">
      Paddle Speed: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSpeed">
      Paddle Gravity: <input type="range" min="1" max="100" value="50" class="slider" id="paddleGravity">
      Paddle Sampling Period: <input type="range" min="1" max="100" value="50" class="slider" id="paddleSampling">
      Paddle Position: <input type="range" min="1" max="100" value="0" class="slider" id="paddlePos">
      Sefirot Output: <input type="range" min="1" max="100" value="0" class="slider" id="sfrOutput">
      </font>
    </div>
    
    <textarea columns="120" rows="7" id="config" style="width:100%;display:none" onchange="window.reconfigure=this.value">
n=1000; //prefixlengthstart
minprefixboundary = 5; 
indiscriminateChoicefullnessBound = 9; 
discriminateChoicefullnessBound = 1000;
sfrAudioChBound = 3
sfrGraphicsChBound = 9
//renderTimeout=5;
//remder=false;
//showCommandLine=false;

    </textarea>
    <br>
    <button id="savemem" >Save Memory</button>
    <button id="loadmem" >Load Memory</button>
    <button id="resetmem" >Reset Memory</button>
    <button id="toggle" onclick="txt=document.getElementById('config');if(txt.style.display=='none')txt.style.display='block'; else txt.style.display='none'">Cfg</button>
    
    <script type="text/javascript" src="https://unpkg.com/butterchurn"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets"></script>
  <script type="text/javascript" src="https://unpkg.com/butterchurn-presets/lib/butterchurnPresetsExtra.min.js"></script>
  
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    
    <script>
      
      //cd /home
      //python3 -m http.server
      //cat /dev/location > /dev/null &

      
      const channels = 10
      
      const span = document.getElementById("out")
        
      const print = (msg) => {
        span.textContent = msg
      }
      
      
      try {
        window.db = new Dexie("SfrMemDatabase");
      
        db.version(1).stores({
          saves: "++id, data",
        });
      } catch (err) {
        print(err)
      }
      
      
      
      var gpu = null 
      var blur = null
      
      var addcircles = null
      
      const width = 1000
      const height = 1000
      
      window.render = true
      
      window.modelExtractionQueue = []
      window.modelExtractionQueueBound = 1000
      
      setInterval(() => {
        modelExtractionQueue.splice(0, -modelExtractionQueueBound)
      }, 10000)
      
      window.modelInjectMemory = (ch, introject) => {
        history[ch].push(...introject)
      }
      
      window.transformBound = 50.0
      window.transformStep = 0.1
      
      try {
        
        window.gpucanvas = document.createElement("canvas");
        gpucanvas.width = 1000
        gpucanvas.height = 1000
        
        const gl =  gpucanvas.getContext('webgl', { preserveDrawingBuffer: true });
        
        
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        gpu = new GPU({
          gpucanvas,
          mode: "webgl",
          context: gl
        });
        
        const n = width
        const m = height
        
        // https://github.com/gpujs/gpu.js/issues/285
        
        blur = gpu.createKernel(function(a, pass, filter, transform, factor) {
              
            let x = this.thread.x
            let y = this.thread.y
            
            
            
            if (transform !== 0.0) {
              let scalex = 1.0
              let addy = 0.0
              let shiftx = 0.0
              
              let scaley = 1.0
              let addx = 0.0
              let shifty = 0.0
              
    
              if (transform == 1.0) {
                scalex += 0.001 * factor;
              } else if (transform == 2.0) {
                addy += (0.001 + 0.001 * x / 1000) * factor 
              } else if (transform == 3.0) {
                shiftx += 0.01 * factor
              } else if (transform == 4.0) {
                scaley += 0.001 * factor
              } else if (transform == 5.0) {
                addx += (0.001 + 0.001 * y / 1000) * factor
              } else if (transform == 6.0) {
                shifty += 0.01 * factor 
              }
              
              x = scalex * this.thread.x + addy * this.thread.y + 1000 * shiftx
              y = scaley * this.thread.y + addx * this.thread.x + 1000 * shifty
              
            }
              
              
              let sum = [0, 0, 0, 0]
              
              
              for (let c = 0; c < 3; c++) {
                for (let i = -pass; i <= pass; i++) {
                  for (let j = -pass; j <= pass; j++) {
                    const value = a[c + 4 * (x + i) + 4 * 1000 * (1000 - y + j)]
                    if (value / 256 > filter) {
                      sum[c] += value
                    }
                  }
                }
              }
              
              let box = (2 * pass + 1) * (2 * pass + 1)
              
              this.color(sum[0] / (256 * box), sum[1] / (256 * box), sum[2] / (256 * box), 0.9)
              
          }).setOutput([n, m]).setGraphical(true)
        
        
        addcircles = gpu.createKernel(function(n, a, transform, factor) {
          
          for (let i = 0; i < n; i++) {
          
            let x = this.thread.x
            let y = this.thread.y
            
            const radius = a[i][0]
            
            if (transform !== 0.0) {
              let scalex = 1.0
              let addy = 0.0
              let shiftx = 0.0
              
              let scaley = 1.0
              let addx = 0.0
              let shifty = 0.0
              
    
              if (transform == 1.0) {
                scalex += 0.001 * factor;
              } else if (transform == 2.0) {
                addy += (0.001 + 0.001 * x / 1000) * factor * 1000 / radius
              } else if (transform == 3.0) {
                shiftx += 0.01 * factor * 1000 / radius;
              } else if (transform == 4.0) {
                scaley += 0.001 * factor
              } else if (transform == 5.0) {
                addx += (0.001 + 0.001 * y / 1000) * factor * 1000 / radius
              } else if (transform == 6.0) {
                shifty += 0.01 * factor * 1000 / radius
              }
              
              x = scalex * this.thread.x + addy * this.thread.y + 1000 * shiftx
              y = scaley * this.thread.y + addx * this.thread.x + 1000 * shifty
              
            }
          
            
            const centerx = a[i][1]
            const centery = a[i][2]
            const r = a[i][3]
            const g = a[i][4]
            const b = a[i][5]
            const alpha = a[i][6]
            
            let dx = x - centerx
            const dy = y - centery
            
            if (transform == 7.0) {
              dx = dx * (1.0 + factor * 0.01 / radius)
            }
            
            if ((dx)**2 + (dy)**2 < radius**2) {
              this.color(r, g, b, alpha)
            } else {
              //this.color(1.0, 1.0, 1.0, 1.0)
            }
          }
          
        }).setOutput([n, m]).setGraphical(true)
        
      } catch (err) {
        console.log(err)
        print(err)
      }
      
      
      
      
      
      const barycentric = (m1, m2, m3, ax = 0.5, ay = 0.15, bx = 0.0, by = 1.0, cx = 1.0, cy = 1.0) => {
        let norm = m1 + m2 + m3
        return [(m1 * ax + m2 * bx + m3 * cx) / norm, (m1 * ay + m2 * by + m3 * cy) / norm]
      }
      
      
      
      const audioElem = new Audio()
      
      window.canvas = window.gpucanvas//document.createElement("canvas");
      canvas.width = 1000
      canvas.height = 1000
      
      window.audioContext = new (window.AudioContext || window.webkitAudioContext) ();
      
        
        
      const streamNode = audioContext.createMediaStreamDestination();
       
      
      var visualizer = null
      
      window.customRenderer = true
      
      window.renderTimeout = 100
      
      const initWinampViz = () => {
         try {
          visualizer = butterchurn.default.createVisualizer(audioContext, canvas, {
            width: 1000,
            height: 1000
          });
          
          // get audioNode from audio source or microphone
          
          
          const mediaSource = audioContext.createMediaStreamSource(streamNode.stream)
          visualizer.connectAudio(mediaSource);
          
          // load a preset
          
          window.presets = butterchurnPresets.getPresets();
          const preset = presets['Flexi, martin + geiss - dedicated to the sherwin maxawow'];
          
          window.presetKeys = Array.from(Object.keys(presets))
          
          //visualizer.loadPreset(preset, 0.0); // 2nd argument is the number of seconds to blend presets
          
          
          
          visualizer.render();
          
        } catch (error) {
          print(error)
        }
      }
      
      if (!customRenderer) {
        initWinampViz()
      }
      
      
      var renderqueue = []
      
  
      
      let hitTransformFactorBound = (ch, value) => {
        
        if (samplingSlider.value < 10) {
          transformBound *= 1.3
          transformStep *= 1.1 + 0.1 * (100 - samplingSlider.value) / 100
        }
        
        let basedelta = 0
        let maxdelta = 0
        
        if ((transformBound * 10).toFixed(0) % 19 == 3) {
          //transformBound = transformBound.toFixed(0) % 60
          transformStep = 0.105
          
          if (chbasefreq[ch] == 0) {
            chbasefreq[ch] = basefreq
          }
          if (chmaxfreq[ch] == 0) {
            chmaxfreq[ch] = maxfreq
          }
          
          if (value % 20 == 0) {
            basedelta = 0.01 * (value / 1000)
          } else {
            maxdelta = 0.03 * (value / 1000)
          }
          
          if ((value / 73) % 2 == 0) {
            basedelta = -basedelta
            maxdelta = -maxdelta
          }
          chbasefreq[ch % sfrAudioChBound] = Math.max(40, Math.min(90, chbasefreq[ch] + 1000 * basedelta))
          chmaxfreq[ch % sfrAudioChBound] = Math.max(120, Math.min(1500, chmaxfreq[ch] + 1000 * maxdelta))
        }
        
        //console.log("expand transform " + transformBound + " " + transformStep + " " + basedelta + " " + maxdelta)
      }
      
      let doBlur = (k, threshold, transform = 0.0, transformFactor = 0.0) => {
        try {
          //const imageData = ctx.getImageData(0, 0, 1000, 1000)
          blur(addcircles.getPixels(), k, threshold, transform, transformFactor)
          //ctx.drawImage(blur.canvas, 0, 0)
        } catch (err){
          print(err)
          console.log("blurrerr=" + err)
        }
      }
      
      let doCircle = (cx, cy, r, h, s, l, a, transform, factor) => {
        try {
          
          function hsl2rgb(h,s,l) {
            let a=s*Math.min(l,1-l);
            let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);
            return [f(0),f(8),f(4)];
          }   
          const rgb = hsl2rgb(h, s, l)
          //print(cx)
          addcircles(1, [r, cx, cy, rgb[0], rgb[1], rgb[2], a], transform, factor)
          //ctx.drawImage(window.gpucanvas, 0, 0)
        } catch (err){
          print(err)
          console.log("circleerr=" + err)
        }
      }
      
      if (true) {
        //const ctx = canvas.getContext("2d");
        
        let initRenderState = () => {
          return {
            m1: 1.0,
            m2: 1.0,
            m3: 1.0,
            light: 1.0,
            blurLevel: 1.0,
            hue: 1.0,
            sat: 1.0,
            brush: 1.0,
            alpha: 1.0,
            transform: 0.0,
            transformFactor: 0.0,
            direction: 1.0
          }
        }
        
        states = []
        var waited = 0
        
        for (i = 0; i < channels; i++) {
          states.push(initRenderState())
        }
        
        const draw = () => {
          
          
          //ctx.fillStyle = "rgb(0 0 0)";
          //ctx.fillRect(25, 25, 100, 100);
          //ctx.clearRect(45, 45, 60, 60);
          //ctx.strokeRect(50, 50, 50, 50);
          
          if (render && customRenderer && gpu !== null) {
            
            
            
            let toRender = [...renderqueue]
            renderqueue = []
            
            
            for (let el of toRender) {
              const ch = el[0]
              const value = el[1]
              const valueInt = (el[1] * 1000).toFixed(0)
              
              const command = valueInt % 10
              const st = states[ch]
              //console.log(command)
              switch (command) {
                case 1: st.m1 = value; break;
                case 2: st.m2 = value; break;
                case 3: st.m3 = value; break;
                case 4: st.light = value; break;
                case 5: st.blurLevel = value; break;
                case 6: st.hue = value; break;
                case 7: st.sat = value; break;
                case 8: st.brush = value; break;
                case 9: st.alpha = value; break;
                case 0: 
                  
                    st.transform = (valueInt / 20) % 8
                    //console.log("aaa")
                    
                    if (valueInt / 160 != 0 ) {
                      if ((valueInt / 160) % 2 == 0 && st.transformFactor <= transformBound){
                        st.transformFactor += st.direction * transformStep
                      } else if ((valueInt / 160) % 2 == 1 && st.transformFactor >= -transformBound) {
                        st.transformFactor -= st.direction * transformStep
                      } else {
                        st.direction = -st.direction
                        hitTransformFactorBound(ch, valueInt)
                      }
                    }
                  
                    break;
                default: print("what" + command + "type = " + typeof(el[1]))
              }
              //let fillStyle = `hsl(${((360 * st.hue).toFixed(0) / 10) * 10} ${(100 * st.sat).toFixed(0) * 0 + 100}% ${(10 * st.light + 40).toFixed(0)}% / ${(5 * st.alpha).toFixed(0)}%)`
              //console.log(fillStyle)
              //ctx.fillStyle = fillStyle
              
              const coords = barycentric(st.m1, st.m2, st.m3)
              //ctx.beginPath();
              const base = 10 + st.light * 2
              const radius = Math.pow(2, st.brush * base)
              //ctx.arc(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, 0, 2 * Math.PI);
              //ctx.arc(coords[0] * 1000, coords[1] * 1000, 1000 * st.brush, 0, 2 * Math.PI);
              
              //ctx.fill()
              
              const transform = st.transform 
              const factor = st.transformFactor
              
              doCircle(-350 + coords[0] * 1700, -500 + coords[1] * 1500, radius, ((360 * st.hue).toFixed(0) / 10) * 10, 1.0, st.light* 0.1 + 0.4, 0.01 + 0.05 * st.alpha, transform, factor)
              
              //print(waited)
              if (waited < renderTimeout) {
                const t0 = performance.now()
                const level = (st.blurLevel * 100)
                if (level > 70) {
                  let filterFactor = 0.1
                  if (level > 80) {
                      filterFactor = 0.4
                  }
                  
                  doBlur(1 + ((6 * (st.blurLevel)).toFixed(0) / 3) * 3, filterFactor * st.sat)
                }
                
                const t1 = performance.now()
                waited = (t1 - t0)
              } else {
                waited -= 1.0
                if (waited < 0) {
                  waited = 0
                }
              }
              
              
            }
            if (states[0].blurLevel > 0.01) {
              
              let viewportTransform = 0
              let blurWindow = 3
              let filter = 0.01
              if (states[1].blurLevel < 0.05) {
                if (states[2].blurLevel < 0.04) {
                  blurWindow = 0
                  filter = 0.0
                }
                viewportTransform = states[2].transform
              }
              doBlur(3, 0.01, viewportTransform, states[3].transformFactor)
            }
            
          } 
            
          if (visualizer != null) {
            visualizer.render();
          }
          
          
          window.requestAnimationFrame(draw)
        
        }
        try {
          window.requestAnimationFrame(draw)
        } catch (message) {
          print(message)
        }
        
        
      }
      
      var canvasStream = canvas.captureStream()
      
      
      
      const videoElem = document.createElement("video");
      videoElem.srcObject = canvasStream
      
      audioElem.controls = true;
      audioElem.autoplay = false;
      
      videoElem.autoplay = true
      videoElem.controls = true
      
      videoElem.onpause = () => {
        audioElem.pause()
        
      } 
      
      videoElem.onplay = () => {
        audioElem.play()
      }
      window.overrideCanvas = false
      
      videoElem.onvolumechange = () => {
        
        if (visualizer != null && videoElem.muted && !customRenderer) {
          
          
          
          function getRandomInt(max) {
            return Math.floor(Math.random() * max);
          }
          
          if (window.overrideCanvas && getRandomInt(7) == 2) {
            customRenderer = true
            window.winampCanvasStream = videoElem.srcObject
            videoElem.srcObject = canvasStream
            
            print('RUNNING')
          } else {
            const npresets = window.presetKeys.length
            const randomPresetName = window.presetKeys[getRandomInt(npresets)]
            const preset = presets[randomPresetName];
            print(randomPresetName)
            visualizer.loadPreset(preset, 0.0); 
          }
          
         
        
        } else if (videoElem.muted) {
          customRenderer = false
          
          if (window.overrideCanvas == false) {
            window.overrideCanvas = true
          
            window.overridenCanvas = window.canvas
            window.canvas = document.createElement("canvas");
            canvas.width = 1000
            canvas.height = 1000
          
            videoElem.srcObject = canvas.captureStream()
          
            initWinampViz()
          } else {
            videoElem.srcObject = window.winampCanvasStream
          }
          
        }
      }
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(canvas)
      document.body.appendChild(document.createElement("br"))
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(audioElem);
      
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(document.createElement("br"))
      document.body.appendChild(videoElem);
      
      
      console.log("666")
      
      
  
      
      
      setTimeout(() => {  
        
        window.oscillatorNode = []
        
        window.reconfigure = ""
        
        window.sfrAudioChBound = 3
        window.sfrGraphicsChBound = 9
        
        window.maxfreq = 120
        window.basefreq = 60
        
        window.chbasefreq = Array.from({length: channels}, () => 0)
        window.chmaxfreq = Array.from({length: channels}, () => 0)
      
        
        //40 350
        window.discretisation = 40.0
        
        setInterval(() => {
          (1,eval)(window.reconfigure)
        }, 1000)
        
        
        var history = []
        window.n = 1000
        var m = 10000000
        
        window.showCommandLine=true
        window.commandLine = ""
        const characterSet = "@ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ()/\*+=[]{}#%_~<>!?,.0123456789-';"
        
        setInterval(() => {
          //let i = ((pos)*100).toFixed(0)
          let i = document.getElementById("sfrOutput").value
          if (i < characterSet.length) {
            const candidate = characterSet[i]
            //print("" + i + " " + candidate)
            if (candidate !== commandLine[commandLine.length-1]) {
              commandLine = commandLine + candidate
            }
            
          } else {
            commandLine = commandLine.slice(0, -1)
            if (commandLine.length == 1) {
              commandLine = ""
            }
          }
          
          if (commandLine.length > 30) {
            commandLine = ""
          }
          const toPrint = commandLine.replace('@', '')
          if (toPrint.length === 0) {
            //print('OBSERVING')
          } else {
            if (showCommandLine) {
              print('>' + toPrint)
              try {
                (1,eval)(toPrint)
              } catch {
                
              }
            }
          }
        }, 10)
        
        const saveState = () => {
          const encoded = JSON.stringify(history)
          //localStorage.setItem('memory', encoded)
          db.saves.put({id:0, data: encoded})
          
        }
        
          
        
        const tryload = () => {
          //const stored = localStorage.getItem('memory')
          
          
          db.saves.toArray().then((sv) => {
            const stored = sv.map(x => x.data)[0] ?? null
          
            if (stored !== null && stored !== "null") {
              //alert(storedCells)
              
              const memory = JSON.parse(stored)
              if (channels === memory.length) {
                history = memory
                console.log(history)
              } else {
                alert("ignoring history " + memory.length)
              }
              
            } else {
              console.log("no history found!")
            }
            
          })
        }
        
        
        window.memory = history
        
        setInterval(saveState, 5000)
        
              
        
        const gainNode = audioContext.createGain()
        
        
        
        let filter = audioContext.createBiquadFilter();
        
        filter.type = "lowpass"
        filter.frequency.setTargetAtTime(2000, audioContext.currentTime, 0);
        
        
        
        let compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressor.knee.setValueAtTime(40, audioContext.currentTime);
        compressor.ratio.setValueAtTime(12, audioContext.currentTime);
        compressor.attack.setValueAtTime(0, audioContext.currentTime);
        compressor.release.setValueAtTime(0.25, audioContext.currentTime);
        
        
        gainNode.connect(filter)
        filter.connect(compressor)
        compressor.connect(streamNode)
        
        const beep = (frequency, i = 0) => {
          //console.log("" + i + "   " + frequency + "  " + gainNode.gain.value)
          
          if (window.oscillatorNode[i]) {
            let delay = 0.05
            
            if (frequency == 0) {
              activeChannells[i] = 0
            } else {
              if (window.oscillatorNode[i].frequency === 0) {
                delay += 0.1
              }
              activeChannells[i] = 1
            }
            
            const activity = activeChannells.reduce((accumulator, current) => accumulator + current, 0);
            
            if (activity > 1) {
              gainNode.gain.setTargetAtTime(1.0 / activity, window.audioContext.currentTime, discretisation / 1000)
            } else {
              gainNode.gain
                .setTargetAtTime(1.0, window.audioContext.currentTime + delay + discretisation * (channels + 1) / 1000, discretisation * (channels + 1) / 1000)
            }
             
            window.oscillatorNode[i]
              .frequency.linearRampToValueAtTime(frequency, 
                window.audioContext.currentTime + discretisation / 1000 + delay)
            //console.log("f" + Math.ceil(frequency, 0))
          }
        }
        
        
        
        const activeChannells = []
        
        
        const initChannells = () => {
          const rehistory = history.length != 0
          for (i = 0; i < channels; i ++) {
            window.oscillatorNode.push(audioContext.createOscillator())
            window.oscillatorNode[i].type = "sine"
            window.oscillatorNode[i].connect(gainNode);
            if (!rehistory) {
              history.push([])
              activeChannells.push(0)
            }
            
            window.oscillatorNode[i].frequency.value = 0
          }
        }
        
        initChannells()
        
        tryload()
        
        
        
        console.log("6669")
        
              
        
        
        
        window.started = false
        const permission = () => {
          
          //const source = audioContext.createMediaStreamSource(combinedStream);
          audioElem.srcObject = streamNode.stream
          
          //oscillatorNode.connect(audioContext.destination);
          
          if (window.started) {
            for (i = 0; i < channels; i ++) {
              oscillatorNode[i].stop();
            }
            oscillatorNode = []
            initChannells()
            alert("awake!")
          }
          
          for (i = 0; i < channels; i ++) {
            oscillatorNode[i].start();
          }
          
          audioElem.volume =1.0
          audioElem.play()
          window.started = true
          
          DeviceMotionEvent.requestPermission()
          print('RUNNING')
          
        }
        
        const btn = document.getElementById( "request" );
        btn.addEventListener( "click", permission );
        
        
        
        
        const loadmem = (event) => {
          navigator.clipboard.readText().then((stateTxt) => {
            try {
               let memory = JSON.parse(atob(stateTxt))
              audioElem.pause()
              if (channels === memory.length) {
                history = memory
                alert("loaded from clipboard")
              } else {
                alert('LOAD STATE ERROR: WRONG AMOUNT OF CH: ' + memory.length)
              }
              audioElem.play()
              
            } catch (err) {
              alert(err)
              audioElem.play()
              
            }
           
            
          })
          
          
        }
        
        const savemem = () => {
          audioElem.pause()
          
          navigator.clipboard.writeText(btoa(JSON.stringify(history)))
          audioElem.play()
          
          alert("saved to clipboard!")
          audioElem.play()
        }
        
        const resetmem = () => {
          audioElem.pause()
          history = history.map(x => [])
          audioElem.play()
          alert('reset')
        }
        
        const btn2 = document.getElementById("savemem");
        btn2.addEventListener( "click", savemem );
        
        const btn3 = document.getElementById("loadmem");
        btn3.addEventListener( "click", loadmem);
        
        
        const btn4 = document.getElementById("resetmem");
        btn4.addEventListener( "click", resetmem );
        
        const speedSlider = document.getElementById("paddleSpeed")
        speedSlider.oninput = (e) => {
           window.speed = speedSlider.value / 10
        }
        
        const gravitySlider = document.getElementById("paddleGravity")
        gravitySlider.oninput = () => {
          window.gravity = gravitySlider.value / 100
        }
        
        window.samplingSlider = document.getElementById("paddleSampling")
        samplingSlider.oninput = () => {
          clearInterval(window.transitionScheduler)
          window.discretisation = samplingSlider.value / 1.0
          setInterval(window.transition, window.discretisation)
        }
        
        const posSlider = document.getElementById("paddlePos")
        posSlider.oninput = () => {
          window.pos = posSlider.value / 100
        }
        
        const outSlider = document.getElementById("sfrOutput")
        
        
        
        var prev = [0,0,0]
        var energy = 0.001
        
        var energyThreshold = 0.9
        var minEnergy = 0.0
        var energyScale = 1.0
        
        ondevicemotion = (event) => {
          
          var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
          var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
          prev = [x, y, z]
          energy = energyScale * (dx * dx + dy * dy + dz * dz)
          if (energy > energyThreshold || energy < minEnergy) {
            energy = energyThreshold * energyScale
          }
          
        }
        
        //print("999")
        
        window.lag = 5 //5
        window.minprefixboundary = 5
        window.indiscriminateChoicefullnessBound = 9
        window.discriminateChoicefullnessBound = 1000
        
        
        
        function choice(arr){
          
          let unique = new Set(arr)
          let counts = Array.from(unique).map(x => {
            return [x, arr.filter(v => v===x).length]
          }).sort((a, b) => b[1] - a[1])
        
          return counts
            .slice(0, discriminateChoicefullnessBound)
            .pop()[0]
          
          
          //return arr.sort((a,b) =>
            //arr.filter(v => v===b).length - arr.filter(v => v===a).length
          //).pop();
          //return arr[Math.min(longlag, arr.length - 1)]
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
        
        
        
        let predict = (pattern, history) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0
          const N = history.length - pattern.length - lag
          
          let candidates = []
          for (let i = N-1; i >= 0; i--) {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              candidates.push(history[i + pattern.length])
              if (candidates.length >= indiscriminateChoicefullnessBound) {
                break;
              }
            }
          }
          
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          
          return choice(candidates.slice(0, indiscriminateChoicefullnessBound))
          
        }
        
        
        
        window.speed = 6.0
        window.gravity = 0.6
        const posscale = 1.00
        
        const precision = 1000
        const lim = 1.0
        
        window.pos = 0.0
        var orient = 1.0
        var tick = 0
        var i = 0
        
        window.posThreshold = 0.2
        window.outputThreshold = 2
        
        const inferOutput = (pos, output) => {
          if (output < outputThreshold) {
            return (1.0 - Math.abs(pos)) * precision
          } else {
            if (Math.abs(pos) < posThreshold) {
              return output
            } else {
              return (1.0 - Math.abs(pos)) * precision
            }
          }
        }
        
        
        window.transition = () => {
          
          pos = pos + orient * speed * energy - gravity * pos
          tick += 1
          if (tick % 120 == 0) {
            orient = - orient
          }

          if (pos > lim) {
            pos = lim
            orient = - orient
          }
          
          if (pos < - lim) {
            pos = - lim
            orient = - orient
          }
          
          
          i += 1
          i %= channels
          
          posSlider.value = Math.abs(pos) * 100
            
          history[i].splice(0, history[i].length - m)
          const pattern = history[i].slice(1).slice(-n)
          const prediction = Number.parseFloat(predict(pattern, history[i]))
    
          const output = inferOutput(posscale * pos, prediction) / posscale 
            
          const basefreqi = chbasefreq[i] == 0 ? basefreq : chbasefreq[i]
          const maxfreqi = chmaxfreq[i] == 0 ? maxfreq : chmaxfreq[i]
          //console.log("" + basefreqi + " " + maxfreqi + " " + chbasefreq)
          const freq = (basefreqi + 
              output * (maxfreqi - basefreqi) / precision)
              
          if (freq >= maxfreqi - 3) {
            beep(0, i)
          } else {
            history[i].push(output.toFixed(0))
            if (i < sfrGraphicsChBound) {
              renderqueue.push([i, output * 1.0 / precision])
            }
              
            modelExtractionQueue.push([i, output * 1.0 / precision])
              
            outSlider.value = output * 100.0 / precision
              
            if (i < sfrAudioChBound) {
              beep(freq, i)
            }
          }
          
        }
        
        window.transitionScheduler = setInterval(transition, discretisation)
      }, 1000)
      

    </script>
    
    <script type="text/javascript" src="https://unpkg.com/ts-browser"></script>

    
    
    <script type="text/typescript">
      //Required window context: modelExtractionQueue: [[]], modelExtractionQueueBound: number, modelInjectMemory: (ch, introject) => {} 
    
      
      declare global {
        interface Window { 
          modelExtractionQueue: [number, number][]; 
          modelExtractionQueueBound: number
          modelInjectMemory: (ch: number, introject: number) => {} 
        }
      }
      
      type Handler = {
        name: string;
      };
      
      //alert("hello")
      /*

register(prefix, env state prefix, actor state prefix, suffix, output prefix, actor, input_parser, output_encoder, env state parser, env state encoder, actor state parser, actor state encoder, env state comparator, actor state comparator, invalid_actor_state_representation_marker, invalid env state transition).

(input opt, env state, actor state)  => (output opt, expected new env state, new actor state)


<Prefix><input><envstateprefix><envstate><actorstateprefix><actorstate><suffix>INSERT:<output prefix><output> <envstateprefix><envstate><actorstateprefix><actorstate> <suffix>

For prefix:43294, inputs:[584, 13048], results: [5673, 67], env goes from state 6684 to 8909  (predictable to actor) and then to unknown state, actor goes from 99 to 1342 and then to 95

Env state prefix 943
Actor state prefix 789
Suffix 555
Output prefix 666

REWRITES IN SFRT MEMORY

43294584943668478999555
=> 43294584943668478999555666567394389097891342

43294130487891342555 - INVALID ENV STATE TRANSITION (since actor expected 8909)

432941304894389097891342555
=>
4329413048943890978913425556666778995

—-
Actor will retry when state is invalid. If retries are not successful, actor will start rewinding states.

*/
       
    </script>
    
    
    
   
  </body>

</html>