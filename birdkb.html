<html>
    <head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="viewport" content="user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-status-bar-style" content="black-translucent">
    
    </head>
    <body bgcolor="black">
        <button id="gyro" onclick="DeviceMotionEvent.requestPermission()">gyro</button>
        <svg id="cont" style="font-family:'Crafty Girls'; font-size:50px;
      fill:yellow;position: fixed; top:0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
   
        </svg>
        <script>

            var prevX = 0
            var prevY = 0

            setInterval(() => {
                //energy = 0
            }, 100)

            onmousemove = (event) => {                
                ev = {}
                ev.acceleration = {}
                const x = event.clientX / 1000
                const y = event.clientY / 1000
                ev.acceleration.x = event.clientX - prevX
                ev.acceleration.y = event.clientY - prevY
                ev.acceleration.z = 0
                prevX = x
                prevY = y
                ondevicemotion(ev)
            }

            var prev = [0,0,0]
            var energy = 0.001
            
            var energyThreshold = 0.05
            var minEnergy = 0.0
            var energyScale = 1.0
            
            ondevicemotion = (event) => {
                setInterval(() => {
                    document.getElementById("gyro").style.display = 'none'
                }, 100)
                var [x, y, z] = [event.acceleration.x, event.acceleration.y, event.acceleration.z]
                var [dx, dy, dz] = [x - prev[0], y - prev[1], z - prev[2]]
                prev = [x, y, z]
                var [x, y, z] = [dx, dy, dz]
                energy = energyScale * (dx * dx + dy * dy + dz * dz)
                if (energy > energyThreshold) {
                    energy = energyThreshold
                }
                
            
            }

            setInterval(() => {
                energy = 0
            }, 300)
        </script>
               <script>
             
        function choice(arr, discriminateChoicefullnessBound){
          
          let unique = new Set(arr)
          let counts = Array.from(unique).map(x => {
            return [x, arr.filter(v => v===x).length]
          }).sort((a, b) => b[1] - a[1])
        
          return counts
            .slice(0, discriminateChoicefullnessBound)
            .pop()[0]
        
        }
        
        let compare = (arr1, arr2) => {
          for (const [i, x] in arr1.entries()) {
            if (x !== arr2[i]) {
              return false
            }
          }
          
          return true
        }
           
        let predict = (pattern, history, discriminateChoicefullnessBound, indiscriminateChoicefullnessBound, minprefixboundary, lag) => {
          if (pattern.length <= minprefixboundary) return 0
          if (history.length < pattern.length + lag) return 0

          const N = history.length - pattern.length - lag
          
          let candidates = []
          for (let i = N-1; i >= 0; i--) {
            let chunk = history.slice(i, i + pattern.length)
            if (compare(chunk, pattern)) {
              candidates.push(history[i + pattern.length])
              if (candidates.length >= indiscriminateChoicefullnessBound) {
                break;
              }
            }
          }
          
          if (candidates.length == 0){
            return predict(pattern.slice(2), history) 
          }
          
          return choice(candidates.slice(0, indiscriminateChoicefullnessBound), discriminateChoicefullnessBound)
          
        }

        window.infer = (history, n = 1000, m = 10000000, discriminateChoicefullnessBound = 1000, indiscriminateChoicefullnessBound = 9, minprefixboundary = 5, lag = 5) => {
            
            history.splice(0, history.length - m)
            const pattern = history.slice(1).slice(-n)
            const prediction = Number.parseFloat(predict(pattern, history, discriminateChoicefullnessBound, indiscriminateChoicefullnessBound, minprefixboundary, lag))
            return prediction
        }

        window.observe = (symbol, history, precision = 0) => {
            history.push(symbol.toFixed(precision))
        }
          
        </script>
        <script>
        var screenWidth = document.body.clientWidth - 20
        var screenHeight = document.body.clientHeight - 40

         var score = 0
         var highscore = 0
         highscore = localStorage.getItem('highscore') ?? 0
         
         const svgns = "http://www.w3.org/2000/svg"
         const container = document.getElementById( 'cont' );
         container.setAttributeNS(null, "width", screenWidth)
         container.setAttributeNS(null, "height", screenHeight)

         const scoreText = document.createElement("pre");
         scoreText.style = "font-family:'Crafty Girls'; font-size:200px;color:yellow;"
         scoreText.style.position = "fixed"
         scoreText.style.top = -200
         scoreText.style.left = 20
         scoreText.textContent = "00"

        const cpmText = document.createElement("pre");
         cpmText.style = "font-family:'Crafty Girls'; font-size:50px;color:yellow;"
         cpmText.style.position = "fixed"
         cpmText.style.bottom = 30
         cpmText.style.right = 20
         cpmText.textContent = "0 cpm"
         cpmText.style.display = "none"

         setInterval(() => {
            scoreText.innerHTML = score
            cpmText.textContent = (window.cpm ?? 0) + " cpm"
         }, 200)
         
         const start = () => {
            container.innerHTML = ""
            document.body.appendChild(scoreText);
            document.body.appendChild(cpmText);

            score = 0
            
            
            const initx = 200
            const inity = 300
            const radius = 10 * screenHeight / 755
            var x = initx
            var y = inity
            

            const circle = document.createElementNS(svgns, 'circle');
            circle.setAttributeNS(null, 'cx', x);
            circle.setAttributeNS(null, 'cy', y);
            circle.setAttributeNS(null, 'r', radius);
            circle.setAttributeNS(null, 'style', 'fill: blue; stroke: blue; stroke-width: 1px;' );
            container.appendChild(circle);


            y = 0
            var acc = 0
            const alphabet = "_ _ _ _ _<<<□↵abcdefghijklmnopqrstuvwxyz0123456789!?.,:[]{}_ _ _"
                .split("").concat(["lol"]).concat("_ _ _".split(""))
            let stream = []

            let i = 0
            const k = 1000

            let counter = 0
            let candidate = 0
            let lastposition = undefined

            window.counterThreshold = 10
            window.iThreshold = 150
            window.speedFactor = 1

            let timer = undefined
            const timestamps = []
            window.cpm = 0

           setInterval(() => {

                const quantisation = alphabet.length
                const position = (screenHeight - y + 3) / ((screenHeight - 30) / quantisation)
                const cursor = Math.floor(position)
                const distance = (candidate === cursor) ? (1 - 2 * Math.abs(position - cursor - 0.5)) : 0
                const localHeight = position - cursor

                const chdist = Math.abs(candidate - cursor)

                if (energy < 0.01) {
                    i++
                } else {
                    i = i * (1 - 0.01 * energy)
                }

                if (counter < 0) {
                    counter = 0
                }

                lastposition = position

 
                

                
                scoreText.style.color = `hsla(100, 100%, 50%, 0.5)`
    

                const underCursor = alphabet[cursor % alphabet.length] ?? '_'
                const underCursorColor = 
                    //`hsla(100, 100%, 50%, ${0.3 + i / iThreshold })`;
                    `hsla(100, 100%, 50%, ${1.0 })`;
                const underCursorFormatted = `<font style = 'color: ${underCursorColor}''>${underCursor}</font>`
                score = stream.join("") + underCursorFormatted
                
                if (candidate && candidate !== 0 && candidate === cursor && energy < 0.01) {
                    counter++
                }
                
                if (candidate && candidate !== cursor) {
                    i = 0.95 * i 
                    counter = 0
                    //i-=2
                    
                }
                
                candidate = cursor

                            


                if (i % k > iThreshold && counter > counterThreshold) {
                    if (alphabet[cursor % alphabet.length] === "□") {
                        stream.push(" ")
                    } else if (alphabet[cursor % alphabet.length] === "↵") {
                        stream.push("\n")
                    } else if (alphabet[cursor % alphabet.length] === "<") {
                        stream.pop()
                        window.cpm = 0
                        timestamps.length = 0

                    } else if (alphabet[cursor % alphabet.length] !== '_' && alphabet[cursor % alphabet.length] !== ' ') {
                        stream.push(alphabet[cursor % alphabet.length])
                    }
                    i = 1
                    candidate = 0
                    counter = 0
                    y = screenHeight

                    if (timer) {
                        const time = performance.now() - timer
                        timestamps.push(time)
                        timestamps.splice(0, timestamps.length - 4)
                        const avg = timestamps.reduce((a,b)=>a+b, 0) / timestamps.length
                        window.cpm = Math.floor((60000 / avg) ?? 0)

                    }
                    timer = performance.now()
                    if (alphabet[cursor % alphabet.length] === "<") {
                        window.cpm = 0
                        timestamps.length = 0

                    }
                }
                
                const ballspeed = speedFactor * Math.max(0.05, 1 - 0.0001 * (i % k) * (i % k))
                
                
                const gravity =  ballspeed * ((6 + 5 * y / screenHeight) * screenHeight / 755) / 10
                const shift = (y - ballspeed * (energy * energy * 15000 * (screenHeight / 755) * (screenHeight / 755)) / 10)
                y1 = Math.max(0, Math.min(screenHeight, (shift + gravity)))

                if (y1 < 30) {
                    y1 = screenHeight
                    energy = 0
                }

                if (i % k === 0) {
                   y1 = screenHeight
                }
                if (y1 < y) {
                    y = y1 
                } else {
                    y = y1 + gravity * (0.3 * 1000 / shift)
                }

                if (y > screenHeight - 20) {
                    i = 1
                }

  
                
                circle.setAttributeNS(null, 'cx', x);
                circle.setAttributeNS(null, 'cy', y); 
            
            }, 10)
         }
         start()

         document.addEventListener("touchend", (ev) => {
            cpmText.style.display = cpmText.style.display === 'block' ? 'none' : 'block'
         })

         window.onclick = () => {
            cpmText.style.display = cpmText.style.display === 'block' ? 'none' : 'block'
         }



        </script>
    </body>
</html>