<html>
<body style = "background-color: black"></body>
<script>
    console.clear()
    const tg = (name, id, attr = {}) => {
        const el = document.createElement(name)
        el.setAttribute("id", id)
        for(const [k, v] in Object.entries(attr)) {
            el.setAttribute(k, v)
        }
        document.body.appendChild(el)
        return el

    }

    const $ = (name) => {
        return document.getElementById(name)
    }

    const span = tg("span")
    span.textContent = ">"
    span.style.color = "green"
    


</script>

<script>
    //search engine
</script>

<script>
    //free syntax turing parser

    

    // find non-overlapping occurrences of pattern in state (left-to-right)
    function findNonOverlappingOccurrences(state, pattern) {
        const n = state.length, m = pattern.length;
        if (m === 0 || m > n) return [];
        const occ = [];
        for (let i = 0; i <= n - m; ) {
            let ok = true;
            for (let j = 0; j < m; j++) {
            if (state[i + j] !== pattern[j]) { ok = false; break; }
            }
            if (ok) { occ.push(i); i += m; } else { i += 1; }
        }
        return occ;
    }

    // getPossibleIntroSections(state, zeroToken) using non-overlapping matches
    function getPossibleIntroSections(state, zeroToken) {
        if (!Array.isArray(zeroToken) || zeroToken.length === 0) return [];
        const occ = findNonOverlappingOccurrences(state, zeroToken);
        if (occ.length < 2) return [];
        const sections = [];
        const m = zeroToken.length;
        for (let k = 0; k < occ.length - 1; k++) {
            const s = occ[k] + m;       // first index after k-th match
            const e = occ[k + 1] - 1;   // last index before (k+1)-th match
            if (s <= e + 1) sections.push({ start: s, end: e, slice: state.slice(s, e + 1) });
        }
        return sections;
    }

    // helper to count occurrences of a needle (allow overlaps)
    const countOccurrences = (hay, needle) => {
        const n = hay.length, m = needle.length;
        if (m === 0) return 0;
        let c = 0;
        for (let i = 0; i + m <= n; i++) {
        let j = 0;
        while (j < m && hay[i + j] === needle[j]) j++;
        if (j === m) c++;
        }
        return c;
    };

    // input: introSection: BigInt[], state: BigInt[]
    // output: Map<string, {count: number, firstStart: number}>

    // TODO: does not work

    //TODO: EXCLUDE OTHER INTROSECTIONS FROM STATE!!!
    function tokenize(introSection, state) {
        const nIntro = introSection.length, nState = state.length;
        const serialize = (arr, start, len) => {
            let s = '';
            for (let i = 0; i < len; i++) { if (i) s += ','; s += arr[start + i].toString(); }
            return s;
        };

        // 1) candidates that appear >1 times in state
        const inState = new Map(); // key -> stateCount (we only need >1)
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (inState.has(key)) continue;
            let cnt = 0;
            for (let i = 0; i + len <= nState; i++) {
                let j = 0;
                while (j < len && state[i + j] === introSection[s + j]) j++;
                if (j === len) cnt++;
                if (cnt > 1) break;
            }
            if (cnt > 1) inState.set(key, cnt);
            }
        }
        if (inState.size === 0) return new Map();

        // 2) collect positions inside introSection for each candidate (sorted)
        const positions = new Map(); // key -> [start indices]
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (!inState.has(key)) continue;
            if (!positions.has(key)) positions.set(key, []);
            positions.get(key).push(s);
            }
        }
        for (const arr of positions.values()) arr.sort((a,b) => a-b);

        // 3) prepare candidates sorted by descending length (prefer longer tokens)
        const candidates = [];
        for (const [k, cState] of inState.entries()) {
            const len = k === '' ? 0 : k.split(',').length;
            candidates.push({ key: k, len, cState });
        }
        candidates.sort((a, b) => b.len - a.len || b.cState - a.cState || (a.key < b.key ? -1 : 1));

        // 4) select non-overlapping occurrences in introSection,
        //    and record first occurrence start for each token
        const covered = new Array(nIntro).fill(false);
        const result = new Map(); // key -> { count, firstStart }
        for (const cand of candidates) {
            const starts = positions.get(cand.key) || [];
            let taken = 0;
            let firstStart = -1;
            for (const st of starts) {
                // check if this occurrence is free (no overlap with already taken occurrences)
                let conflict = false;
                for (let p = st; p < st + cand.len; p++) {
                    if (covered[p]) { conflict = true; break; }
                }
                if (conflict) continue;
                // take it
                for (let p = st; p < st + cand.len; p++) covered[p] = true;
                if (firstStart === -1) firstStart = st;
                taken++;
            }
            if (taken > 0) result.set(cand.key, { count: countOccurrences(introSection, parseKey(cand.key)), firstStart });
        }

        return result;
    }

    const startsWith = (seq, pat) => {
        if (pat.length > seq.length) return false;
        for (let i = 0; i < pat.length; i++) { if (seq[i] !== pat[i]) return false;}
        return true;
    };

    function findUniqueSuffix(space, label, stopAt) {
        const candidates = [];
        for (let i = 0; i <= space.length - label.length; i++) {
            let match = true;
            for (let j = 0; j < label.length; j++) {
                if (space[i + j] !== label[j]) { match = false; break; }
            }
            if (!match) continue;
            const suffix = [];
            for (let k = i + label.length; k < space.length; k++) {
            let isLabel = true;
            for (let j = 0; j < label.length && k + j < space.length; j++) {
                if (space[k + j] !== label[j]) { isLabel = false; break; }
            }
            if (isLabel) break;
            if (stopAt.some(pat => startsWith(space.slice(k), pat))) break;
                suffix.push(space[k]);
            }
            if (suffix.length > 0) candidates.push(suffix);
        }
        if (candidates.length === 1) return candidates[0];
        return undefined;
    }

    const space = [1n,2n,3n,4n,5n,6n];
    const label = [2n,3n];
    const stopAt = [[5n]];

    console.log("SUFFIX:" + findUniqueSuffix(space, label, stopAt))

    function tokensCoverSection(tokens, section) {
        const startMap = new Map();
        tokens.forEach((tok, idx) => {
            const first = tok[0];
            if (!startMap.has(first)) startMap.set(first, new Set());
            startMap.get(first).add(idx);
        });

        let i = 0;                     
        const used = new Set();       

        while (i < section.length) {
            const candidates = startMap.get(section[i]);
            if (!candidates) return false;
            let matched = false;
            for (const idx of candidates) {
            const tok = tokens[idx];
            if (i + tok.length > section.length) continue;
            let ok = true;
            for (let j = 0; j < tok.length; j++) {
                if (section[i + j] !== tok[j]) { ok = false; break; }
            }
            if (!ok) continue;
            matched = true;
            i += tok.length;          
            break;                   
            }

            if (!matched) return false; 
        }
        return i === section.length;
    }

    function inferIncDec(state, zeroToken) {
        const sections = getPossibleIntroSections(state, zeroToken);

        const emptySections = sections.some(x => x.end - x.start == -1)

        if (sections.length === 0 || emptySections) return [[], [], 0, []]

        const acc = [[], [], 0, []]

        const incDecTokenIntro = state.slice(0, sections[0].start - zeroToken.length)

        for(let i = 0; i < sections.length; i++) {
            const sec = sections[i]

            const intro = sec.slice;

            const tokens = tokenize(intro, incDecTokenIntro.concat(intro)); // Map key -> {count, firstStart}
            if (tokens.size < 2) {
                //console.log(")))))" + parse(enrichSeqNo(incDecTokenIntro)))
                //console.log([...tokens.keys()].map(tk => parse(enrichSeqNo(parseKey(tk)))))
                return [[], [], -(i+1), []]
            }

            const entries = Array.from(tokens.entries());
            const incSet = new Set(), decSet = new Set();
            for (let i = 0; i < entries.length; i++) {
                for (let j = i + 1; j < entries.length; j++) {
                    const [ki, vi] = entries[i];
                    const [kj, vj] = entries[j];
                    if (vi.count > 0 && vi.count === vj.count) {
                        if (vi.firstStart <= vj.firstStart) { incSet.add(ki); decSet.add(kj); }
                        else { incSet.add(kj); decSet.add(ki); }
                    }
                }
            }
            if (incSet.size > 0 && decSet.size > 0) {
                for (const t of Array.from(incSet)) {
                    if (decSet.has(t)) { incSet.delete(t); decSet.delete(t); }
                }

                const merged = [...(new Set([...incSet, ...decSet]))].map(parseKey)
                if (!tokensCoverSection(merged, intro)){
                    return acc
                }

                acc[0] = Array.from(new Set([...(new Set(acc[0])), ...incSet]))
                acc[1] =  Array.from(new Set([...(new Set(acc[1])), ...decSet]))
                acc[2] = i + 1
                acc[3].push(sec)

                //console.log("-----" + parse(enrichSeqNo(zeroToken)))
                //console.log("++++++" + parse(enrichSeqNo(incDecTokenIntro)))

                
            } else {
                return acc
            }

        }

        return acc;
    }

    function parseKey(key) {
        return key.split(',').map(s => BigInt(s));
    }

    function countVar(state, tokenisation) {
        const [incs, decs] = tokenisation || [[], []];

        // build list of needles (arrays) from keys
        const makeNeedles = (keys) => keys.map(k => ({ key: k, arr: parseKey(k), len: k === '' ? 0 : k.split(',').length }));
        const incNeedles = makeNeedles(incs);
        const decNeedles = makeNeedles(decs);

        let count = 0;

        for (const n0 of incNeedles) count += countOccurrences(state, n0.arr);
        for (const n0 of decNeedles) count -= countOccurrences(state, n0.arr);

        return count;
    }

    const eraseSeqNo = (seq) => {
        return seq.map(x => x[0])
    }

    const enrichSeqNo = (seq) => {
        return seq.map((x, i) => [x, i])
    }

    //todo enrich original token seqNo into turing machine

    const zeroBranch = (state, seq) => {
        for (let i = 0; i < seq.length; i++) {
            const candidate = eraseSeqNo(seq.slice(0, i))
            const inference = inferIncDec(eraseSeqNo(state), candidate)
            if (inference[0].length > 0) {
                const [incs, decs, secCount, sections] = inference
                if (incs.length > 1 || decs.length > 1) {
                    continue
                }
                return {
                    varName:  parse(enrichSeqNo(candidate)),
                    zero: enrichSeqNo(candidate), 
                    incs: incs.map(x => enrichSeqNo(parseKey(x))), 
                    decs: decs.map(x => enrichSeqNo(parseKey(x))),
                    incNames: incs.map(x => parse(enrichSeqNo(parseKey(x)))),
                    decNames: decs.map(x => parse(enrichSeqNo(parseKey(x)))),
                    secCount: secCount, 
                    sections: sections
                }
            }
        }
       return undefined

    }

    const checkIfEndsWithToken = (output, tokens) => {
        for (token of tokens) {
            const strippedToken = eraseSeqNo(token)
            const strippedOutput = eraseSeqNo(output.slice(-token.length))

            if (bigIntArraysEqual(strippedToken, strippedOutput)) {
                return true
            }
        }

        return false
    }

    const parseIncDec = (inference) => {
        const [incs, decs, count] = inference
        const incsData = incs.map(inc => parse(enrichSeqNo(parseKey(inc))))
        const decsData = decs.map(dec => parse(enrichSeqNo(parseKey(dec))))

        return `incs: ${incsData}; decs: ${decsData}; sections=${count}`

    }



console.log("HELLO")
const intro = [1n,2n,3n,2n,3n];
const state2 = [1n,3n,0n,4n,1n,2n,0n, 3n,2n,1n,2n,1n,2n];
const map = tokenize(intro, state2);
for (const [k,v] of map) console.log(k, '->', v);


</script>


<script>
    const MAX_UNICODE = 0x10FFFFn;

    function entityToBigInt(fragment) {
        const decMatch = fragment.match(/^&#(\d+);$/);
        if (decMatch) return BigInt(decMatch[1]);

        const hexMatch = fragment.match(/^&#x([0-9a-fA-F]+);$/);
        if (hexMatch) return BigInt('0x' + hexMatch[1]);

        return null;
    }

    function cpToString(cp) {
        if (cp <= MAX_UNICODE) {
            return String.fromCodePoint(Number(cp));
        }
        return `&#${cp.toString()};`;
    }

    function tokenToBigInt(token) {
        const entity = entityToBigInt(token);
        if (entity !== null) return entity;

        // token is a normal character – get its code point
        const cp = token.codePointAt(0);
        return BigInt(cp);
    }

    function render(input) {
        const result = [];
        let pos = 0;
        let i = 0;

        while (i < input.length) {
            if (input[i] === '&') {
                const semi = input.indexOf(';', i + 1);
                if (semi !== -1) {
                    const candidate = input.slice(i, semi + 1);
                    const big = entityToBigInt(candidate);
                    if (big !== null) {
                    result.push([big, pos++]);
                    i = semi + 1;
                    continue;
                    }
                }
            }

            const cp = input.codePointAt(i);
            result.push([BigInt(cp), pos++]);

            i += cp > 0xFFFF ? 2 : 1;
        }

        if (result.length === 1 && !result[0]) return []
        return result;
    }

    function parse(state) {
        if (state === undefined || state.length === 0 || (state.length === 1 && !state[0])) return ''

        return state
            .map(([cp]) => cpToString(cp))
            .join('');
    }


</script>

<script>

    //turing executor and termination oracle

    function inferMembound(turing) {
        const base = turing.filter(x => x[1] !== 0n && x[1] < TURING_OFFSET).length
        return {
            currentExpansion: base,
            currentHyperop: 0n,
            hyperopBound: turing.filter(x => x[1] > TURING_OFFSET).length,
            baseBound: base,
        }

    }

    function powBigInt(base, exponent) {
        base = BigInt(base);
        exponent = BigInt(exponent);
        if (exponent < 0n) throw new RangeError('negative exponent not supported for BigInt');
        let result = 1n;
        while (exponent > 0n) {
            if (exponent & 1n) result *= base;
            base *= base;
            exponent >>= 1n;
        }
        return result;
    }

    function checkMembound(value, membound) {

        let counter = 0n
        while (membound.currentExpansion < value && membound.currentHyperop < membound.hyperopBound) {
            counter++
            if (counter > 30n) {
                console.log(membound)
                throw "check mem overflow"
            }
            membound.currentExpansion = powBigInt(membound.currentExpansion, membound.baseBound)
            membound.currentHyperop++
        }

        return membound.currentExpansion >= value

    }

    function minBigInt(arr) {
        if (arr.length === 0) return undefined
        return arr.reduce((a, b) => (a < b ? a : b));
    }

    function maxBigInt(arr) {
        if (arr.length === 0) return undefined
        return arr.reduce((a, b) => (a > b ? a : b));
    }

    const getJumpDestination = jump => jump[1] - TURING_OFFSET

    const createJumpDestination = cur => cur + TURING_OFFSET

    const getLoopVar = jump => jump[0]

    const filterCov = (coverage, start, end) => new Set([...coverage].filter(x => x >= start && x <= end))

    function checkLoopSegment(turing, coverage, jump, cursor, memory, lastLoopVarState, lastCov) {

        if (!lastLoopVarState || !lastCov) return true
        const loopStart = getJumpDestination(jump)
        const loopEnd = cursor
        if (loopStart > loopEnd) return true

        const loopVarIdx = getLoopVar(jump)
        const loopVar = memory[loopVarIdx]

        const segmentJumps = turing.slice(Number(loopStart), Number(loopEnd)).map(getJumpDestination).filter(x => x >= 0n)
        const minDest = minBigInt(segmentJumps)
        const maxDest = maxBigInt(segmentJumps) > loopEnd ? BigInt(turing.length-1) : loopEnd
        //todo improve up to any instruction that jumps above loopEnd

        const expandedStart = minDest === undefined ? loopStart : minBigInt([loopStart, minDest])
        const expandedEnd = maxDest === undefined ? loopEnd : maxBigInt([loopStart, maxDest])

        //todo check if expanded segment refers to variables in current segment

        //todo check if dec extruction mentioned for loopvar at all

        //todo exclude unreachable segments - no dec instruction for forward jmp
        
        const segmentCov = filterCov(coverage, expandedStart, expandedEnd)
        const segmentLastCov = filterCov(coverage, expandedStart, expandedEnd)


        if (BigInt(segmentCov.size) >= expandedEnd - expandedStart && loopVar >= lastLoopVarState && loopVar !== 0n) {
            return false
        }

        return true
    }

    function bigIntArraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false; // BigInt compared with ===
        }
        return true;
    }

    function checkRepeatCfg(state, cursor, history) {
        for (const x of history){
            const [pastCursor, pastState] = x
            if (pastCursor === cursor && bigIntArraysEqual(pastState, state)) {
                return false
            }
        }
        return true
    }

    const TURING_INC = 2n
    const TURING_DEC = 1n
    const TURING_OUT = 0n
    const TURING_OFFSET = 100n

    const TURING_JMP = (instrPointer) => instrPointer + TURING_OFFSET

    //input is sequence of [mem_address, instr_address]
    //instr_address past offset jmpnz mem_address (instr_address - offset)
    //other instr_address as inc dec out
    function executeTuring(turing, ctx = {}) {
  
        ctx.trace = []
        ctx.membound = inferMembound(turing)
        const membound = ctx.membound

        let cursor = 0n

        ctx.memory = []
        const memory = ctx.memory

        const output = []

        ctx.history = []
        const history = ctx.history

        ctx.coverage = new Set()
        const coverage = ctx.coverage

        const lastCoverageForJmp = {}
        const lastLoopVarStateForJmp = {}

        let safeCounter = 0n

        while (cursor < turing.length) {
            ctx.trace.push(cursor)
            safeCounter++
            if (safeCounter > 3000n) {
                console.log(ctx)
                console.log(printTuring(turing))
                throw "overflow " + cursor
            }

            const [mem, instr] = turing[cursor]

            if (instr === TURING_OUT) {
                output.push(mem)
                coverage.add(cursor)
                cursor++
            } else if (instr === TURING_INC) {
                if (memory[mem] === undefined) memory[mem] = 0n
                memory[mem]++
                if(!checkMembound(memory[mem], membound)) {

                    const loopJmp = turing.findLastIndex(x => x[1] >= TURING_OFFSET + BigInt(turing.length))
                    
                    const noOuterJumps = loopJmp && !turing.slice(loopJmp).some(x => x[1] > TURING_OFFSET && x[1] < TURING_OFFSET + BigInt(loopJmp))
                    if (noOuterJumps) {
                        memory[turing[loopJmp][0]] = mem
                        cursor = loopJmp
                    } else {
                        console.log("LOOP HYPER: " + cursor)
                        ctx.loopHyper = cursor
                        ctx.loopState = memory[mem]
                        return output
                    }
                    
                } else {
                    coverage.add(cursor)
                    cursor++
                }
                
            } else if (instr === TURING_DEC) {
                if (memory[mem] === undefined) memory[mem] = 0n
                memory[mem]--
                if (memory[mem] < 0n) memory[mem] = 0n
                coverage.add(cursor)
                cursor++
            } else {
                if (memory[mem] === undefined) memory[mem] = 0n
                if (memory[mem] === 0n) {
                    cursor++
                } else {

                    const nextCursorShift = turing.slice(Number(cursor) + 1).findIndex(x => x[1] !== TURING_OUT)
                    const nextCursor = nextCursorShift === -1 ? turing.length + 1 : cursor + BigInt(nextCursorShift) + 1n
                    coverage.add(cursor)
                    const lastCov = lastCoverageForJmp[cursor.toString]
                    const lastLoopVarState = lastLoopVarStateForJmp[cursor.toString]
                    const nonTerminationRecovery = turing[nextCursor] && turing[nextCursor][1] - TURING_OFFSET !== cursor && turing[nextCursor][1] > TURING_OFFSET && turing[nextCursor][0] === mem //for theorem provers

                    if (!checkLoopSegment(turing, coverage, turing[cursor], cursor, memory, lastLoopVarState, lastCov)) {
                        if (nonTerminationRecovery) {
                            cursor = nextCursor
                        } else {
                            console.log("LOOP SEG: " + cursor)
                            ctx.loopSegment = cursor
                            return output
                        }  
                    } else {
                        cursor = instr - TURING_OFFSET
                        if (!checkRepeatCfg(memory, cursor, history)) {
                        
                            if (nonTerminationRecovery) {
                                cursor = nextCursor
                            } else {
                                console.log("LOOP REPEAT: " + cursor)
                                ctx.loopRepeat = cursor
                                return output
                            }
                        }
                        lastCoverageForJmp[cursor.toString] = coverage
                        lastLoopVarStateForJmp[cursor.toString] = memory[mem]

                    }
                    
                }
            }
            
        }

        return output
    }

    function genJump(turing, varIdx, label) {
        const outs = turing
            .map((x,i) => [x[0], x[1], BigInt(i)])
            .filter(x => x[1] === 0n)
            .map(x => [x[0], x[2]]) //char, line_no

            
        const instrPointer = find(outs, label)[0] //take first label
        if (instrPointer === undefined) {
            return undefined
        }
        return [varIdx, instrPointer[1] + TURING_OFFSET]
    }

    function genStubJmp(turing, varIdx) {
        return [varIdx, BigInt(turing.length) + TURING_OFFSET + 1n]
    }


    function genInc(varIdx) {
        return [varIdx, TURING_INC]
    }

    function genDec(varIdx) {
        return [varIdx, TURING_DEC]
    }

    function genOut(next) {
        return [next[0], 0n]
    }

    function printTuring(turing, parseOut=true) {
        return turing.map((x, i) => {
            if (x[1] === TURING_INC) {
                return `${i}: inc \$${x[0]}`
            } else if (x[1] === TURING_DEC) {
                return `${i}: dec \$${x[0]}`
            } else if (x[1] === TURING_OUT) {
                return `${i}: out ${parseOut ? parse([[x[0], 0]]):x[0]}`
            } else {
                return `${i}: jmp \$${x[0]} -> ${getJumpDestination(x)}`
            }
        }).join("\n")
    }

    const ctxTuring = {}
    const program = [
        [0n,   TURING_INC], 
        [0n,   TURING_JMP(0n)], 
        [0n,   TURING_JMP(4n)], 
        [20n,  TURING_OUT],
        [-1n,   TURING_OUT], 
        [0n,   TURING_INC], 
    ]

    const program2 = [
        [0n,   TURING_INC], 
        [0n,   TURING_JMP(0n)], 
        [0n,  TURING_OUT],
        [0n,   TURING_JMP(100n)], 
        [-1n,   TURING_OUT], 
    ]

    console.log("\n\nTURING TEST")

    console.log(printTuring(program, false))

    const output = executeTuring(program, ctxTuring)

    console.log("TURING OUT: " + output)

    console.log(ctxTuring)

    console.log("TURING END\n\n\n")



</script>

<script>
    //prediction

    const range = limit => Array.from({ length: limit + 1 }, (_, i) => i);

    const createMask = (length, maskCfg) => {
        return new Set()
    }

    const makeKey = (arr) => arr.map(x => x.toString()).join(",")

    const find = (state, pattern, ctx = { }) => {

        
        if (!ctx.transform) ctx.transform = new Map();
        const masks = ctx.masks || {};
        const sMask = masks.stateMask   instanceof Set ? masks.stateMask   : new Set();
        const pMask = masks.patternMask instanceof Set ? masks.patternMask : new Set();
        const bMask = masks.blurMask    instanceof Set ? masks.blurMask    : new Set();
        const aMask = masks.attention ?? []

        ctx.currentMasks = {
            stateMask:   new Set(sMask),
            patternMask: new Set(pMask),
            blurMask:    new Set(bMask),
            attention:   aMask
        };

        if (!ctx.transform) ctx.transform = new Map();

        const blurredPattern = blurArray(pattern, bMask);
        if (blurredPattern.length === 0) return [];

        const effectivePatLen = blurredPattern.length - pMask.size;
        const result = [];

        for (let start = 0; start <= state.length - effectivePatLen; start++) {
            const windowSlice = state
                .slice(start, start + blurredPattern.length)
                .map((x, i) => aMask[i] ? state[start + i - aMask[i]] : x)
                .map(cell => cell[0]); 

            const blurredWindow = blurArray(windowSlice, bMask);

            let patIdx = 0;
            let winIdx = 0;


            //todo infer sMask and bMask from pattern vs window simillarity
            //todo try different insertions/deletions/blurs and attentions to maximize simillarity
            //but only applied them to mismatched parts (symmetrically if mismatch is in the middle)

            //todo use ctx.masks.attentionPattern or ctx.masks.attention
            //it will be map from index in pattern to the shift of this index backwards in state

            //ctx.fuzzyBound + ctx.simllarityScore is a limit for search of modifications and blurs

            let ok = true;
            while (patIdx < blurredPattern.length) {
                if (pMask.has(patIdx)) {
                    patIdx++;
                    continue;
                }

                while (sMask.has(start + winIdx)) winIdx++;
                const stateVal = blurredWindow[winIdx];
                const patVal   = blurredPattern[patIdx];
                if (stateVal !== patVal) {
                    ok = false;
                    break;
                }
                patIdx++;
                winIdx++;
            }

            if (ok) {
                //todo report similarity score for a match
                //maxout simillarity score in result

                const origStateSeg   = state
                    .slice(start, start + pattern.length)
                    .map(cell => cell[0]);

                const origPatternSeg = pattern.slice(); 

                const emitRules = (stateArr, patternArr, next) => {
                    let i = 0;
                    let j = 0; 

                    while (i < patternArr.length || j < stateArr.length) {
                        const stateMasked   = sMask.has(start + j);
                        const patternMasked = pMask.has(i);

                        if (stateMasked || patternMasked) {
                            const stateRun   = [];
                            const patternRun = [];

                            while (j < stateArr.length && sMask.has(start + j)) {
                                stateRun.push(stateArr[j]);
                                j++;
                            }

                            while (i < patternArr.length && pMask.has(i)) {
                                patternRun.push(patternArr[i]);
                                i++;
                            }

                            const stateRule   = stateRun.map(v => v.toString()).join('');
                            const patternRule = patternRun.map(v => v.toString()).join('');

                            if (!ctx.transform.has(stateRule)) {
                                ctx.transform.set(stateRule, {});
                            }
                            if (ctx.transform.get(stateRule)[makeKey(next)] === undefined) {
                                ctx.transform.get(stateRule)[makeKey(next)] = []
                            }
                            ctx.transform.get(stateRule)[makeKey(next)].push(patternRule)
                        } else {
                            if (i < patternArr.length) i++;
                            if (j < stateArr.length)   j++;
                        }
                    }
                };

                const nextIdx = start + winIdx;
                const next = state[nextIdx];

                emitRules(origStateSeg, origPatternSeg, next);
 
                if (next) result.push(next);
            }
        }

        return result;
    }

    function blurArray(arr, blurMask) {
        const out = [];
        let i = 0;
        while (i < arr.length) {
            if (!blurMask.has(i)) {
            out.push(arr[i]);
            i++;
            continue;
            }
            let sum = 0n;
            while (i < arr.length && blurMask.has(i)) {
            sum += arr[i];
            i++;
            }
            out.push(sum);
        }
        return out;
    }


    const inferMaskingBound = (len) => {
        return 2
    }

    const findFuzzy = (state, ctx, len, previousMany) => {
        ctx.fuzzyBound = previousMany?.length

        const pattern = state.slice(state.length - len)  
        const matches = find(state.slice(0, -len), pattern.map(x => x[0]), ctx);

        return matches

    }

    const predict = (state, ctx = {}) => {
        if (state.length === 0) return undefined;
        let previousMany = undefined;
        let fuzzyBound = 0n
        ctx.noMatchesAtLen = false

        for (let len = 1; len <= state.length; len++) {

            const matches = findFuzzy(state, ctx, len, previousMany)

            ctx.n = len - 1

            if (matches.length === 0) {
                return previousMany
            } else {
                previousMany = matches;
               
                continue;
            }
        }

        return undefined;
    }

    function pickRelevantTransform(next, ctx) {
        if (!ctx.transform) return;
        ctx.currentTransform = {}
        for (const [ruleIn, ruleOutMulti] of ctx.transform.entries()) {
            for (const [el, ruleOut] of ruleOutMulti) {
                if (next[0] === parseKey(el)[0]) {
                    ctx.currentTransform[ruleIn] = ruleOut[ruleOut.length - 1]
                }
            } 
        }
    }

    function predictDeterministic(state, ctx = {}) {
        let result = predict(state, ctx); 
        ctx.roll = false 
        ctx.nores = false

        if (!result || result.length === 1) {
            ctx.nores = true
            pickRelevantTransform(result[0], ctx)
            return result?.[0] ?? result;
        }

        while (Array.isArray(result) && result.length > 1) {
            const refined = predict(result);
            if (!refined) break;
            if (refined.length === 1) {
                result = refined;
                break;
            }
            result = refined;
        }


        if (result.length > 1) {
            ctx.roll = true
        }

        pickRelevantTransform(result[0], ctx)
        return result[0]
    }

    function pairEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }

    function checkRepeat(output) {
        const n = output.length;
        if (n === 0) return false;

        const pi = new Array(n).fill(0);

        for (let i = 1; i < n; i++) {
            let j = pi[i - 1];
            while (j > 0 && !pairEquals(output[i], output[j])) {
                j = pi[j - 1];
            }
            if (pairEquals(output[i], output[j])) j++;
            pi[i] = j;
        }

        const period = n - pi[n - 1];
        if (pi[n - 1] > 0 && n % period === 0) {
            return period;          // length of the minimal repeating block
        }
        return 0;
    }

    function maxValueBy(array, iteratee) {
        if (!Array.isArray(array) || array.length === 0) return undefined;
        const fn = typeof iteratee === 'function' ? iteratee : (o) => o[iteratee];
        let bestVal = fn(array[0]);
        for (let i = 1; i < array.length; i++) {
            const val = fn(array[i]);
            if (val > bestVal) bestVal = val;
        }
        return bestVal;
    }

    function countUniqueBy(array, predicate) {
        if (!Array.isArray(array) || array.length === 0) return 0;
        const fn = typeof predicate === 'function' ? predicate : (o) => o[predicate];
        const seen = new Set();
        for (const item of array) seen.add(fn(item));
        return seen.size;
    }

    function deleteAllOccurrences(arr, token) {
        if (token.length === 0) return [...arr];
        const result = [];
        for (let i = 0; i < arr.length; ) {
            let match = true;
            if (i + token.length <= arr.length) {
            for (let j = 0; j < token.length; j++) {
                if (arr[i + j] !== token[j]) {
                match = false;
                break;
                }
            }
            } else {
                match = false;
            }

            if (match) {
                i += token.length;
            } else {
                result.push(arr[i]);
                i += 1;
            }
        }
        return result;
    }

    function filterVars(vars) {
        // ---- step 1: keep max secCount ----
        const maxSec = Math.max(...Object.values(vars).map(v => v.secCount));
        const candidates = Object.entries(vars).filter(([, v]) => v.secCount === maxSec);

        // ---- step 2: drop vars whose sections are nested inside another var ----
        const survive = {};

        // helper: does any section of a appear inside any section of b ?
        const isNested = (a, b) => {
            for (const secA of a.sections) {
            for (const secB of b.sections) {
                if (secA.start >= secB.start && secA.end <= secB.end) {
                return true; // a's section lies within b's
                }
            }
            }
            return false;
        };

        // compare each candidate against the others
        for (const [nameA, varA] of candidates) {
            let discard = false;
            for (const [nameB, varB] of candidates) {
            if (nameA === nameB) continue;
            if (isNested(varA, varB)) {
                discard = true;          // A is inside B → remove A
                break;
            }
            }
            if (!discard) survive[nameA] = varA;
        }

        return survive;
    }


    function inlineTuring(state, output, ctx) {
        if (ctx.turing === undefined) ctx.turing = []
        if (ctx.varCount === undefined) ctx.varCount = 0n
        if (ctx.vars === undefined) ctx.vars = {}
        if (ctx.varIdx === undefined) ctx.varIdx = {}
        if (ctx.allTokensErased === undefined) ctx.allTokensErased = []
        if (ctx.unboundLabels === undefined) ctx.unboundLabels = {}
        if (ctx.unboundLabelNames === undefined) ctx.unboundLabelNames = {}
        if (ctx.labels === undefined) ctx.labels = {}

        const predictCtx = {}

        for (let i = 0; i < output.length; i++) {
            const branches = predict(output.slice(0, i), predictCtx) ?? []

            //todo consider searching for intro sections in predicted 
            const found = zeroBranch(state, output.slice(i))

            if (found !== undefined && branches.length > 0) {

                if (!ctx.vars[found.varName]) {
                    ctx.varCount++
                    ctx.vars[found.varName] = found
                    ctx.varIdx[found.varName] = ctx.varCount

                    ctx.allTokensErased.push(eraseSeqNo(found.zero))
            
                    found.incs.forEach(x => ctx.allTokensErased.push(eraseSeqNo(x)))
                    found.decs.forEach(x => ctx.allTokensErased.push(eraseSeqNo(x)))
                }
            } 
        }    

        ctx.vars = ctx.vars ? filterVars(ctx.vars) : undefined

        for (let i = 0; i < output.length; i++) {
            const found = zeroBranch(state, output.slice(i))

            const prepend = found ? enrichSeqNo(deleteAllOccurrences(eraseSeqNo(output.slice(i)), eraseSeqNo(found.zero))) : []
            const space = prepend.concat(output.slice(0, i))
            const branches = predict(space, predictCtx) ?? []
            
            if (found !== undefined && branches.length > 0 && ctx.vars[found.varName]) {
                //console.log(parse(space))
  

                const varIdx = ctx.varIdx[found.varName]
                const label = output.slice(i-predictCtx.n, i)

                const labelSearchSpace = output.slice(0, i-predictCtx.n).concat(output.slice(i))

                const labelSuffix = findUniqueSuffix(eraseSeqNo(labelSearchSpace), eraseSeqNo(label), ctx.allTokensErased)

                if (labelSuffix) {
        
                    const labelName = label.concat(enrichSeqNo(labelSuffix))
                    
                    const jump = genJump(ctx.turing, varIdx, eraseSeqNo(labelName))
                    if (!jump) {
                        const fullLabel = label.concat(enrichSeqNo(labelSuffix))
                        ctx.unboundLabels[ctx.turing.length] = fullLabel
                        ctx.unboundLabelNames[parse(fullLabel)] = ctx.turing.length
                        ctx.turing.push(genStubJmp(ctx.turing, varIdx))
                        
                    } else {
                        ctx.labels[parse(labelName)] = jump[1] - TURING_OFFSET
                        ctx.turing.push(jump)
                    }
                    
                }
            } 
    
            
            const genIdx = (incOrDec) => {
                for (const [name, zero] of Object.entries(ctx.vars)) {
                    if (checkIfEndsWithToken(output.slice(0, i), zero[incOrDec])) {
                        if (incOrDec === "incs") {
                            ctx.turing.push(genInc(ctx.varIdx[name]))
                        } else {
                            ctx.turing.push(genDec(ctx.varIdx[name]))
                        }
                    }
                }
            }
            
            genIdx("incs")
            genIdx("decs")

            for (const [cur, label] of Object.entries(ctx.unboundLabels)) {
                //console.log("+++" + parse(label) + " " + ctx.turing.length + "(((()))) " + parse(output.slice(0, i)))
                if (checkIfEndsWithToken(output.slice(0, i), [label])) {
                    ctx.labels[parse(label)] = BigInt(ctx.turing.length)

                    ctx.turing[cur][1] = createJumpDestination(BigInt(ctx.turing.length))
                }
            }
       
            ctx.turing.push([output[i][0], 0n])
        }
    }

    function inlineMacroses(output, ctx) {
        //todo: use ctx.transform rules (ensure termination)

        return output
    }

    function predictContinuously(initState, ctx = {}) {

        let state = [...initState];
        let output = [];

        ctx.loop = false

        let counter = 0

        while (true) {
            counter++
            

            let next = predictDeterministic(state);

            if (ctx.order && output.length > 0) {
                if (next[1] !== output[output.length - 1][1] + 1) {
                    return output
                }
            }
    
            if (!next) break;
            output.push(next);

            if (ctx.expandMacroses) {
                output = inlineMacroses(output, ctx)
            }

            const limit = countUniqueBy(output, x => x[1])

            if (counter > limit) {
                output.forEach(el => {
                    el[1] = 0
                })
            }

            if (counter > 1000) {
                throw "overflow " + parse(state) + "\n" + output.map(x => `${x[1]}: ${parse([x])}\n`).join('')
            }

            const repeatLen = checkRepeat(output)
            
            if (repeatLen > 0) {
                
                const keep = output.length - repeatLen; 
                output.splice(keep, repeatLen);
                if (ctx.turing) {
                    ctx.turing.splice(ctx.turing.length / 2, ctx.turing.length / 2)
                }
                ctx.loop = true
                break;                                  
            }
        
            state = [...state, next]; 
        }
        

        if (ctx.inlineTuring) {
            inlineTuring(initState, output, ctx)
        }

        if (ctx.executeTuring && ctx.turing) {
            //todo macro post-processing: invoke repeat continously but with current output and turing off
            return enrichSeqNo(executeTuring(ctx.turing, ctx))
        }

        ctx.transform = undefined
        ctx.currentTransform = undefined

        return output  
    }

    

    function stringifyWithBigInt(obj) {
        return JSON.stringify(obj, (_, value) =>
            typeof value === "bigint" ? value.toString() : value
        );
    }
</script>


<script>

    //const state = render(" Welcome to the terminal! Welcome to the world! Welcome to the terminal! Welcome to the world! Welcome")
    const state = render(`
    plus minus
    zeroplusminuszeroplusminuszero
    program
label:
    
    plus
    labelzero
    lab2zero
    hello
lab2:
    minus
    program`)

    console.log("N:" + state.slice(-1)[0][1])
    tg("br")

    const span2 = tg("span", "res")
    span2.textContent = parse(find(state, render("l").map(x => x[0])))
    span2.style.color = "green"

    tg("br")

    const span7 = tg("span", "res")
    const ctx7 = {target:2}
    span7.textContent = "" + parse(predict(state, ctx7))
    span7.style.color = "green"

    tg("br")

    const span3 = tg("span", "res")
    const ctx = {}
    span3.textContent = "PREDICT: " + parse([predictDeterministic(state, ctx)]) + "; n = " + ctx.n + "; roll = " + ctx.roll + "; nores = " + ctx.nores
    span3.style.color = "green"

    tg("br")


    const ctx2 = {}
    //ctx2.order = true
    ctx2.inlineTuring = true //todo slow
    ctx2.executeTuring = true
    console.log("STREAM")
    const span4 = tg("span", "res")
    span4.textContent = "STREAM: " + parse(predictContinuously(state, ctx2)) + "   ;;; loop = " + ctx2.loop + " ;;; turingLength=" + ctx2.turing?.length
    span4.style.color = "green"

    //span4.textContent = stringifyWithBigInt(ctx2)
    console.log(ctx2)
    console.log(printTuring(ctx2.turing))


    tg("br")
    tg("br")
    const span5= tg("span", "res")
    const ctx3 = {}
    console.log("BRANCHING")
    //span5.textContent = "BRANCHING: " + parse(predictContinuously(render("0+-0+++l -l0l"), ctx3)) + "  ;; branches = " + ctx3.branch
    
    //todo move sections to the output scope
    //require jmp to be after section
    const st2 = eraseSeqNo(render("plus minus0plusminus0 pl:plusl0p"))
    const p2 = eraseSeqNo(render("0"))
    span5.textContent = "BRANCHING: " + parseIncDec(inferIncDec(st2, p2))
    span5.style.color = "green"
</script>


</html>