<html>
<body style = "background-color: black"></body>
<script>
    const tg = (name, id, attr = {}) => {
        const el = document.createElement(name)
        el.setAttribute("id", id)
        for(const [k, v] in Object.entries(attr)) {
            el.setAttribute(k, v)
        }
        document.body.appendChild(el)
        return el

    }

    const $ = (name) => {
        return document.getElementById(name)
    }

    const span = tg("span")
    span.textContent = ">"
    span.style.color = "green"
    


</script>

<script>
    //search engine
</script>

<script>
    //free syntax turing parser

    // find non-overlapping occurrences of pattern in state (left-to-right)
    function findNonOverlappingOccurrences(state, pattern) {
        const n = state.length, m = pattern.length;
        if (m === 0 || m > n) return [];
        const occ = [];
        for (let i = 0; i <= n - m; ) {
            let ok = true;
            for (let j = 0; j < m; j++) {
            if (state[i + j] !== pattern[j]) { ok = false; break; }
            }
            if (ok) { occ.push(i); i += m; } else { i += 1; }
        }
        return occ;
    }

    // getPossibleIntroSections(state, zeroToken) using non-overlapping matches
    function getPossibleIntroSections(state, zeroToken) {
        if (!Array.isArray(zeroToken) || zeroToken.length === 0) return [];
        const occ = findNonOverlappingOccurrences(state, zeroToken);
        if (occ.length < 2) return [];
        const sections = [];
        const m = zeroToken.length;
        for (let k = 0; k < occ.length - 1; k++) {
            const s = occ[k] + m;       // first index after k-th match
            const e = occ[k + 1] - 1;   // last index before (k+1)-th match
            if (s <= e) sections.push({ start: s, end: e, slice: state.slice(s, e + 1) });
        }
        return sections;
    }

    // helper to count occurrences of a needle (allow overlaps)
    const countOccurrences = (hay, needle) => {
        const n = hay.length, m = needle.length;
        if (m === 0) return 0;
        let c = 0;
        for (let i = 0; i + m <= n; i++) {
        let j = 0;
        while (j < m && hay[i + j] === needle[j]) j++;
        if (j === m) c++;
        }
        return c;
    };

    // input: introSection: BigInt[], state: BigInt[]
    // output: Map<string, {count: number, firstStart: number}>

    // TODO: does not work
    function tokenize(introSection, state) {
        const nIntro = introSection.length, nState = state.length;
        const serialize = (arr, start, len) => {
            let s = '';
            for (let i = 0; i < len; i++) { if (i) s += ','; s += arr[start + i].toString(); }
            return s;
        };

        // 1) candidates that appear >1 times in state
        const inState = new Map(); // key -> stateCount (we only need >1)
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (inState.has(key)) continue;
            let cnt = 0;
            for (let i = 0; i + len <= nState; i++) {
                let j = 0;
                while (j < len && state[i + j] === introSection[s + j]) j++;
                if (j === len) cnt++;
                if (cnt > 1) break;
            }
            if (cnt > 1) inState.set(key, cnt);
            }
        }
        if (inState.size === 0) return new Map();

        // 2) collect positions inside introSection for each candidate (sorted)
        const positions = new Map(); // key -> [start indices]
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (!inState.has(key)) continue;
            if (!positions.has(key)) positions.set(key, []);
            positions.get(key).push(s);
            }
        }
        for (const arr of positions.values()) arr.sort((a,b) => a-b);

        // 3) prepare candidates sorted by descending length (prefer longer tokens)
        const candidates = [];
        for (const [k, cState] of inState.entries()) {
            const len = k === '' ? 0 : k.split(',').length;
            candidates.push({ key: k, len, cState });
        }
        candidates.sort((a, b) => b.len - a.len || b.cState - a.cState || (a.key < b.key ? -1 : 1));

        // 4) select non-overlapping occurrences in introSection,
        //    and record first occurrence start for each token
        const covered = new Array(nIntro).fill(false);
        const result = new Map(); // key -> { count, firstStart }
        for (const cand of candidates) {
            const starts = positions.get(cand.key) || [];
            let taken = 0;
            let firstStart = -1;
            for (const st of starts) {
                // check if this occurrence is free (no overlap with already taken occurrences)
                let conflict = false;
                for (let p = st; p < st + cand.len; p++) {
                    if (covered[p]) { conflict = true; break; }
                }
                if (conflict) continue;
                // take it
                for (let p = st; p < st + cand.len; p++) covered[p] = true;
                if (firstStart === -1) firstStart = st;
                taken++;
            }
            if (taken > 0) result.set(cand.key, { count: countOccurrences(introSection, parseKey(cand.key)), firstStart });
        }

        return result;
    }


    function inferIncDec(state, zeroToken) {
        const sections = getPossibleIntroSections(state, zeroToken);
        if (sections.length === 0) return [[], []]
        const sec = sections[0]

        const intro = sec.slice;
        const tokens = tokenize(intro, state); // Map key -> {count, firstStart}
        if (tokens.size < 2) return [[], []] ;

        const entries = Array.from(tokens.entries());
        const incSet = new Set(), decSet = new Set();
        for (let i = 0; i < entries.length; i++) {
            for (let j = i + 1; j < entries.length; j++) {
                const [ki, vi] = entries[i];
                const [kj, vj] = entries[j];
                if (vi.count > 0 && vi.count === vj.count) {
                    if (vi.firstStart <= vj.firstStart) { incSet.add(ki); decSet.add(kj); }
                    else { incSet.add(kj); decSet.add(ki); }
                }
            }
        }
        if (incSet.size > 0) {
            for (const t of Array.from(incSet)) {
                if (decSet.has(t)) { incSet.delete(t); decSet.delete(t); }
            }
            return [Array.from(incSet), Array.from(decSet)];
        }

        return [[], []];
    }

        // tokenisation: [incsArray, decsArray] where each element is token key (comma-joined BigInt string)
    // state: BigInt[]
    function parseKey(key) {
        return key.split(',').map(s => BigInt(s));
    }

    function countVar(state, tokenisation) {
        const [incs, decs] = tokenisation || [[], []];

        // build list of needles (arrays) from keys
        const makeNeedles = (keys) => keys.map(k => ({ key: k, arr: parseKey(k), len: k === '' ? 0 : k.split(',').length }));
        const incNeedles = makeNeedles(incs);
        const decNeedles = makeNeedles(decs);

        let count = 0;

        for (const n0 of incNeedles) count += countOccurrences(state, n0.arr);
        for (const n0 of decNeedles) count -= countOccurrences(state, n0.arr);

        return count;
    }

    const eraseSeqNo = (seq) => {
        return seq.map(x => x[0])
    }

    const enrichSeqNo = (seq) => {
        return seq.map(x => [x, 0])
    }

    const zeroBranch = (state, seq) => {
        for (let i = 0; i < seq.length; i++) {
            const candidate = eraseSeqNo(seq.slice(0, i))
            const inference = inferIncDec(eraseSeqNo(state), candidate)
            if (inference[0].length > 0) {
                const [incs, decs] = inference
                return {
                    zero: enrichSeqNo(candidate), 
                    incs: incs.map(x => enrichSeqNo(parseKey(x))), 
                    decs: decs.map(x => enrichSeqNo(parseKey(x)))
                }
            }
        }
       return undefined

    }

    const parseIncDec = (inference) => {
        const [incs, decs] = inference
        const incsData = incs.map(inc => parse(enrichSeqNo(parseKey(inc))))
        const decsData = decs.map(dec => parse(enrichSeqNo(parseKey(dec))))

        return `incs: ${incsData}; decs: ${decsData}`


    }



console.log("HELLO")
const intro = [1n,2n,3n,2n,3n];
const state2 = [0n, 0n,    1n,2n,3n,2n,3n, 0n, 0n, 4n,1n,2n,0n, 3n,2n,1n,2n,1n,2n];
const map = tokenize(intro, state2);
for (const [k,v] of map) console.log(k, '->', v);

const zeroToken = [0n, 0n];
const [incs, decs] = inferIncDec(state2, zeroToken);
console.log('incs =', incs);
console.log('decs =', decs);

console.log("count = " + countVar(state2, [incs, decs]))


</script>


<script>
    const MAX_UNICODE = 0x10FFFFn;          // highest defined Unicode scalar value

    function entityToBigInt(fragment) {
        const decMatch = fragment.match(/^&#(\d+);$/);
        if (decMatch) return BigInt(decMatch[1]);

        const hexMatch = fragment.match(/^&#x([0-9a-fA-F]+);$/);
        if (hexMatch) return BigInt('0x' + hexMatch[1]);

        return null;
    }

    function cpToString(cp) {
        if (cp <= MAX_UNICODE) {
            // String.fromCodePoint works with Numbers, so we cast safely
            return String.fromCodePoint(Number(cp));
        }
        // otherwise emit a decimal numeric entity
        return `&#${cp.toString()};`;
    }

    function tokenToBigInt(token) {
        const entity = entityToBigInt(token);
        if (entity !== null) return entity;

        // token is a normal character – get its code point
        const cp = token.codePointAt(0);
        return BigInt(cp);
    }

    function render(input) {
        const result = [];
        let pos = 0;
        let i = 0;

        while (i < input.length) {
            // Look ahead for an entity starting with '&'
            if (input[i] === '&') {
            // Find the terminating ';' (if any)
            const semi = input.indexOf(';', i + 1);
            if (semi !== -1) {
                const candidate = input.slice(i, semi + 1);
                const big = entityToBigInt(candidate);
                if (big !== null) {
                result.push([big, pos++]);
                i = semi + 1;
                continue;
                }
            }
            }

            // Normal character (may be a surrogate pair → use codePointAt)
            const cp = input.codePointAt(i);
            result.push([BigInt(cp), pos++]);

            // Advance by 1 code unit for BMP chars, 2 for surrogate pairs
            i += cp > 0xFFFF ? 2 : 1;
        }

        return result;
    }

    function parse(state) {
        return state
            .map(([cp]) => cpToString(cp))
            .join('');
    }


</script>

<script>
    //prediction

    const find = (state, pattern) => {
        const result = [];
        if (pattern.length === 0) {
            return state.map(() => undefined);
        }

        for (let i = 0; i <= state.length - pattern.length; i++) {
            let match = true;
            for (let j = 0; j < pattern.length; j++) {
                if (state[i + j][0] !== pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                const nextCh = state[i + pattern.length]
                if (nextCh) {
                    result.push(nextCh);
                }
            }
        }

        return result;
    }

    const unique = (state, pattern) => {
       return find(state, pattern).length === 1
    }

    const exists = (state, pattern) => {
        return find(state, pattern).length >= 1
    }

    const many = (state, pattern) => {
        return find(state, pattern).length > 1
    }

    const none = (state, pattern) => {
        return find(state, pattern).length === 0
    }

    const predict = (state, ctx = {}) => {
        if (state.length === 0) return undefined;

        let previousMany = null;

        for (let len = 1; len <= state.length; len++) {
            const pattern = state.slice(state.length - len); 
            const matches = find(state.slice(0, -len), pattern.map(x => x[0]));

            ctx.n = len

            if (matches.length === 1) {
                return matches;
            }

            if (matches.length > 1) {
                previousMany = matches;
                continue;
            }

            if (previousMany) {
                return previousMany
            }
        }

        return undefined;
    }

    function predictDeterministic(state, ctx = {}) {
        let result = predict(state, ctx); 
        ctx.roll = false 
        ctx.nores = false

        if (!result || result.length === 1) {
            ctx.nores = true
            return result?.[0] ?? result;
        }

        while (Array.isArray(result) && result.length > 1) {
            const refined = predict(result);
            if (!refined) break;
            if (refined.length === 1) {
                result = refined;
                break;
            }
            result = refined;
        }


        if (result.length > 1) {
            ctx.roll = true
        }

        return result[0]
    }

    function pairEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }

    function checkRepeat(output) {
        const n = output.length;
        if (n === 0) return false;

        const pi = new Array(n).fill(0);

        for (let i = 1; i < n; i++) {
            let j = pi[i - 1];
            while (j > 0 && !pairEquals(output[i], output[j])) {
                j = pi[j - 1];
            }
            if (pairEquals(output[i], output[j])) j++;
            pi[i] = j;
        }

        const period = n - pi[n - 1];
        if (pi[n - 1] > 0 && n % period === 0) {
            return period;          // length of the minimal repeating block
        }
        return 0;
    }

    function maxValueBy(array, iteratee) {
        if (!Array.isArray(array) || array.length === 0) return undefined;
        const fn = typeof iteratee === 'function' ? iteratee : (o) => o[iteratee];
        let bestVal = fn(array[0]);
        for (let i = 1; i < array.length; i++) {
            const val = fn(array[i]);
            if (val > bestVal) bestVal = val;
        }
        return bestVal;
    }

    function countUniqueBy(array, predicate) {
        if (!Array.isArray(array) || array.length === 0) return 0;
        const fn = typeof predicate === 'function' ? predicate : (o) => o[predicate];
        const seen = new Set();
        for (const item of array) seen.add(fn(item));
        return seen.size;
    }

    function checkIntroSection(candidate, state) {

    }

    function predictContinuously(initState, ctx = {}) {
        let state = [...initState];
        const output = [];

        ctx.loop = false

        let counter = 0

        while (true) {
            counter++
            

            const next = predictDeterministic(state);

            if (ctx.order) {
                if (next[1] !== state[state.length - 1][1]) {
                    return output
                }
            }
       
            if (!next) break;
            output.push(next);

            const limit = countUniqueBy(output, x => x[1])

            if (counter > limit) {
                output.forEach(el => {
                    el[1] = 0
                })
            }

            if (counter > 1000) {
                throw "overflow " + parse(state) + "\n" + output.map(x => `${x[1]}: ${parse([x])}\n`).join('')
            }

            const repeatLen = checkRepeat(output)
            //const repeatLen = checkRepeat(output.map(x => [x[0], 0]));
            if (repeatLen > 0) {
                
                const keep = output.length - repeatLen; 
                output.splice(keep, repeatLen);
                ctx.loop = true
                break;                                  
            }

           
            state = [...state, next]; 
        }

        return output  
    }


</script>


<script>
    
    //const state = render(" Welcome to the terminal! Welcome to the world! Welcome to the terminal! Welcome to the world! Welcome")
    const state = render("0+-0++l0-l:---l0--l0-l")
    //const state = render("+-0+++l-l0")

    console.log("N:" + state.slice(-1)[0][1])
    tg("br")

    const span2 = tg("span", "res")
    span2.textContent = parse(find(state, render("l").map(x => x[0])))
    span2.style.color = "green"

    tg("br")

    const span3 = tg("span", "res")
    const ctx = {}
    span3.textContent = "PREDICT: " + parse([predictDeterministic(state, ctx)]) + "; n = " + ctx.n + "; roll = " + ctx.roll + "; nores = " + ctx.nores
    span3.style.color = "green"

    tg("br")


    const ctx2 = {}
    const span4 = tg("span", "res")
    span4.textContent = "STREAM: " + parse(predictContinuously(state, ctx2)) + "   ;;; loop = " + ctx2.loop
    span4.style.color = "green"

    tg("br")
    tg("br")
    const span5= tg("span", "res")
    const ctx3 = {}
    console.log("BRANCHING")
    //span5.textContent = "BRANCHING: " + parse(predictContinuously(render("0+-0+++l -l0l"), ctx3)) + "  ;; branches = " + ctx3.branch
    span5.textContent = "BRANCHING: " + parseIncDec(inferIncDec(eraseSeqNo(render("0+-0++l:-l0l")), eraseSeqNo(render("0"))))
    span5.style.color = "green"
</script>


</html>