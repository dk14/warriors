<html>
<body style = "background-color: black"></body>
<script>
    const tg = (name, id, attr = {}) => {
        const el = document.createElement(name)
        el.setAttribute("id", id)
        for(const [k, v] in Object.entries(attr)) {
            el.setAttribute(k, v)
        }
        document.body.appendChild(el)
        return el

    }

    const $ = (name) => {
        return document.getElementById(name)
    }

    const span = tg("span")
    span.textContent = ">"
    span.style.color = "green"
    


</script>

<script>
    //search engine
</script>

<script>
    //free syntax turing parser

    // find non-overlapping occurrences of pattern in state (left-to-right)
    function findNonOverlappingOccurrences(state, pattern) {
        const n = state.length, m = pattern.length;
        if (m === 0 || m > n) return [];
        const occ = [];
        for (let i = 0; i <= n - m; ) {
            let ok = true;
            for (let j = 0; j < m; j++) {
            if (state[i + j] !== pattern[j]) { ok = false; break; }
            }
            if (ok) { occ.push(i); i += m; } else { i += 1; }
        }
        return occ;
    }

    // getPossibleIntroSections(state, zeroToken) using non-overlapping matches
    function getPossibleIntroSections(state, zeroToken) {
        if (!Array.isArray(zeroToken) || zeroToken.length === 0) return [];
        const occ = findNonOverlappingOccurrences(state, zeroToken);
        if (occ.length < 2) return [];
        const sections = [];
        const m = zeroToken.length;
        for (let k = 0; k < occ.length - 1; k++) {
            const s = occ[k] + m;       // first index after k-th match
            const e = occ[k + 1] - 1;   // last index before (k+1)-th match
            if (s <= e) sections.push({ start: s, end: e, slice: state.slice(s, e + 1) });
        }
        return sections;
    }

    // helper to count occurrences of a needle (allow overlaps)
    const countOccurrences = (hay, needle) => {
        const n = hay.length, m = needle.length;
        if (m === 0) return 0;
        let c = 0;
        for (let i = 0; i + m <= n; i++) {
        let j = 0;
        while (j < m && hay[i + j] === needle[j]) j++;
        if (j === m) c++;
        }
        return c;
    };

    // input: introSection: BigInt[], state: BigInt[]
    // output: Map<string, {count: number, firstStart: number}>

    // TODO: does not work
    function tokenize(introSection, state) {
        const nIntro = introSection.length, nState = state.length;
        const serialize = (arr, start, len) => {
            let s = '';
            for (let i = 0; i < len; i++) { if (i) s += ','; s += arr[start + i].toString(); }
            return s;
        };

        // 1) candidates that appear >1 times in state
        const inState = new Map(); // key -> stateCount (we only need >1)
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (inState.has(key)) continue;
            let cnt = 0;
            for (let i = 0; i + len <= nState; i++) {
                let j = 0;
                while (j < len && state[i + j] === introSection[s + j]) j++;
                if (j === len) cnt++;
                if (cnt > 1) break;
            }
            if (cnt > 1) inState.set(key, cnt);
            }
        }
        if (inState.size === 0) return new Map();

        // 2) collect positions inside introSection for each candidate (sorted)
        const positions = new Map(); // key -> [start indices]
        for (let s = 0; s < nIntro; s++) {
            for (let len = 1; s + len <= nIntro; len++) {
            const key = serialize(introSection, s, len);
            if (!inState.has(key)) continue;
            if (!positions.has(key)) positions.set(key, []);
            positions.get(key).push(s);
            }
        }
        for (const arr of positions.values()) arr.sort((a,b) => a-b);

        // 3) prepare candidates sorted by descending length (prefer longer tokens)
        const candidates = [];
        for (const [k, cState] of inState.entries()) {
            const len = k === '' ? 0 : k.split(',').length;
            candidates.push({ key: k, len, cState });
        }
        candidates.sort((a, b) => b.len - a.len || b.cState - a.cState || (a.key < b.key ? -1 : 1));

        // 4) select non-overlapping occurrences in introSection,
        //    and record first occurrence start for each token
        const covered = new Array(nIntro).fill(false);
        const result = new Map(); // key -> { count, firstStart }
        for (const cand of candidates) {
            const starts = positions.get(cand.key) || [];
            let taken = 0;
            let firstStart = -1;
            for (const st of starts) {
                // check if this occurrence is free (no overlap with already taken occurrences)
                let conflict = false;
                for (let p = st; p < st + cand.len; p++) {
                    if (covered[p]) { conflict = true; break; }
                }
                if (conflict) continue;
                // take it
                for (let p = st; p < st + cand.len; p++) covered[p] = true;
                if (firstStart === -1) firstStart = st;
                taken++;
            }
            if (taken > 0) result.set(cand.key, { count: countOccurrences(introSection, parseKey(cand.key)), firstStart });
        }

        return result;
    }


    function inferIncDec(state, zeroToken) {
        const sections = getPossibleIntroSections(state, zeroToken);
        if (sections.length === 0) return [[], []]
        const sec = sections[0]

        const intro = sec.slice;
        const tokens = tokenize(intro, state); // Map key -> {count, firstStart}
        if (tokens.size < 2) return [[], []] ;

        const entries = Array.from(tokens.entries());
        const incSet = new Set(), decSet = new Set();
        for (let i = 0; i < entries.length; i++) {
            for (let j = i + 1; j < entries.length; j++) {
                const [ki, vi] = entries[i];
                const [kj, vj] = entries[j];
                if (vi.count > 0 && vi.count === vj.count) {
                    if (vi.firstStart <= vj.firstStart) { incSet.add(ki); decSet.add(kj); }
                    else { incSet.add(kj); decSet.add(ki); }
                }
            }
        }
        if (incSet.size > 0) {
            for (const t of Array.from(incSet)) {
                if (decSet.has(t)) { incSet.delete(t); decSet.delete(t); }
            }
            return [Array.from(incSet), Array.from(decSet)];
        }

        return [[], []];
    }

        // tokenisation: [incsArray, decsArray] where each element is token key (comma-joined BigInt string)
    // state: BigInt[]
    function parseKey(key) {
        return key.split(',').map(s => BigInt(s));
    }

    function countVar(state, tokenisation) {
        const [incs, decs] = tokenisation || [[], []];

        // build list of needles (arrays) from keys
        const makeNeedles = (keys) => keys.map(k => ({ key: k, arr: parseKey(k), len: k === '' ? 0 : k.split(',').length }));
        const incNeedles = makeNeedles(incs);
        const decNeedles = makeNeedles(decs);

        let count = 0;

        for (const n0 of incNeedles) count += countOccurrences(state, n0.arr);
        for (const n0 of decNeedles) count -= countOccurrences(state, n0.arr);

        return count;
    }

    const eraseSeqNo = (seq) => {
        return seq.map(x => x[0])
    }

    const enrichSeqNo = (seq) => {
        return seq.map(x => [x, 0])
    }

    const zeroBranch = (state, seq) => {
        for (let i = 0; i < seq.length; i++) {
            const candidate = eraseSeqNo(seq.slice(0, i))
            const inference = inferIncDec(eraseSeqNo(state), candidate)
            if (inference[0].length > 0) {
                const [incs, decs] = inference
                return {
                    varName:  parse(enrichSeqNo(candidate)),
                    zero: enrichSeqNo(candidate), 
                    incs: incs.map(x => enrichSeqNo(parseKey(x))), 
                    decs: decs.map(x => enrichSeqNo(parseKey(x)))
                }
            }
        }
       return undefined

    }

    const checkIfEndsWithToken = (output, tokens) => {
        for (token of tokens) {
            const strippedToken = eraseSeqNo(token)
            const strippedOutput = eraseSeqNo(output.slice(-token.length))

            if (bigIntArraysEqual(strippedToken, strippedOutput)) {
                return true
            }
        }

        return false
    }

    const parseIncDec = (inference) => {
        const [incs, decs] = inference
        const incsData = incs.map(inc => parse(enrichSeqNo(parseKey(inc))))
        const decsData = decs.map(dec => parse(enrichSeqNo(parseKey(dec))))

        return `incs: ${incsData}; decs: ${decsData}`


    }



console.log("HELLO")
const intro = [1n,2n,3n,2n,3n];
const state2 = [0n, 0n,    1n,2n,3n,2n,3n, 0n, 0n, 4n,1n,2n,0n, 3n,2n,1n,2n,1n,2n];
const map = tokenize(intro, state2);
for (const [k,v] of map) console.log(k, '->', v);

const zeroToken = [0n, 0n];
const [incs, decs] = inferIncDec(state2, zeroToken);
console.log('incs =', incs);
console.log('decs =', decs);

console.log("count = " + countVar(state2, [incs, decs]))


</script>


<script>
    const MAX_UNICODE = 0x10FFFFn;          // highest defined Unicode scalar value

    function entityToBigInt(fragment) {
        const decMatch = fragment.match(/^&#(\d+);$/);
        if (decMatch) return BigInt(decMatch[1]);

        const hexMatch = fragment.match(/^&#x([0-9a-fA-F]+);$/);
        if (hexMatch) return BigInt('0x' + hexMatch[1]);

        return null;
    }

    function cpToString(cp) {
        if (cp <= MAX_UNICODE) {
            // String.fromCodePoint works with Numbers, so we cast safely
            return String.fromCodePoint(Number(cp));
        }
        // otherwise emit a decimal numeric entity
        return `&#${cp.toString()};`;
    }

    function tokenToBigInt(token) {
        const entity = entityToBigInt(token);
        if (entity !== null) return entity;

        // token is a normal character – get its code point
        const cp = token.codePointAt(0);
        return BigInt(cp);
    }

    function render(input) {
        const result = [];
        let pos = 0;
        let i = 0;

        while (i < input.length) {
            // Look ahead for an entity starting with '&'
            if (input[i] === '&') {
            // Find the terminating ';' (if any)
            const semi = input.indexOf(';', i + 1);
            if (semi !== -1) {
                const candidate = input.slice(i, semi + 1);
                const big = entityToBigInt(candidate);
                if (big !== null) {
                result.push([big, pos++]);
                i = semi + 1;
                continue;
                }
            }
            }

            // Normal character (may be a surrogate pair → use codePointAt)
            const cp = input.codePointAt(i);
            result.push([BigInt(cp), pos++]);

            // Advance by 1 code unit for BMP chars, 2 for surrogate pairs
            i += cp > 0xFFFF ? 2 : 1;
        }

        if (result.length === 1 && !result[0]) return []
        return result;
    }

    function parse(state) {
        if (state === undefined || state.length === 0 || (state.length === 1 && !state[0])) return ''

        return state
            .map(([cp]) => cpToString(cp))
            .join('');
    }


</script>

<script>

    //turing executor and termination oracle

    function inferMembound(turing) {
        return {
            currentExpansion: 0n,
            currentHyperop: 0n,
            hyperopBound: turing.filter(x => x[1] > 2).length,
            baseBound: turing.length,
        }

    }

    function powBigInt(base, exponent) {
        base = BigInt(base);
        exponent = BigInt(exponent);
        if (exponent < 0n) throw new RangeError('negative exponent not supported for BigInt');
        let result = 1n;
        while (exponent > 0n) {
            if (exponent & 1n) result *= base;
            base *= base;
            exponent >>= 1n;
        }
        return result;
    }

    function checkMembound(value, membound) {

        while (membound.currentExpansion < value && currentHyperop <= membound.hyperopBound) {
            membound.currentExpansion = powBigInt(membound.currentExpansion, baseBound)
            membound.hyperopBound++
        }

        return membound.currentExpansion > value

    }

    const getJumpDestination = jump => jump[1] - TURING_OFFSET

    const getLoopVar = jump => jump[0]

    const filterCov = (coverage, start, end) => coverage.filter(x => x > start && x < end)

    function checkLoopSegment(coverage, jump, cursor, memory, lastLoopVarState, lastCov) {

        if (!lastLoopVarState || !lastCov) return true
        const loopStart = getJumpDestination(jump)
        const loopEnd = cursor
        if (loopStart >= loopEnd) return true

        const loopVarIdx = getLoopVar(jump)
        const loopVar = memory[loopVarIdx]
        const segmentCov = filterCov(coverage, loopStart, loopEnd)
        const segmentLastCov = filterCov(coverage, loopStart, loopEnd)

        if (segmentCov.length === segmentLastCov.length && loopVar >= lastLoopVarState) {
            return false
        }

        return true
    }

    function bigIntArraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false; // BigInt compared with ===
        }
        return true;
    }

    function checkRepeatCfg(state, cursor, history) {
        for (const x of history){
            const [pastCursor, pastState] = x
            if (pastCursor === cursor && bigIntArraysEqual(pastState, state)) {
                return true
            }
        }
        return false
    }

    const TURING_INC = 2n
    const TURING_DEC = 1n
    const TURING_OUT = 0n //mem_adress interpreted as char then
    const TURING_OFFSET = 10n

    //input is sequence of [mem_address, instr_address]
    //instr_address past offset jmpnz mem_address (instr_address - offset)
    //other instr_address as inc dec out
    function executeTuring(turing, offset = 10n) {
  

        const membound = inferMembound(turing)

        let cursor = 0

        const memory = []

        const output = []

        const history = []

        const coverage = new Set()

        const lastCoverageForJmp = {}
        const lastLoopVarStateForJmp = {}

        while (cursor < turing.length) {

            const [mem, instr] = turing[cursor]

            if (instr === TURING_OUT) {
                output.push(mem)
                coverage.add(cursor)
                cursor++
            } else if (instr === TURING_INC) {
                memory[mem]++
                if(!checkMembound(memory[mem], membound)) {
                    return output
                }
                coverage.add(cursor)
                cursor++
            } else if (instr === TURING_DEC) {
                memory[mem]--
                coverage.add(cursor)
                cursor++
            } else {
                if (memory[mem] === 0n) {
                    cursor++
                } else {
                    coverage.add(cursor)
                    const lastCov = lastCoverageForJmp[cursor.toString]
                    const lastLoopVarState = lastLoopVarStateForJmp[cursor.toString]
                    
                    if (!checkLoopSegment(coverage, turing[cursor], cursor, memory, lastLoopVarState, lastCov)) {
                        return output
                    }
                    cursor = instr - TURING_OFFSET
                    if (!checkRepeatCfg(memory, cursor, history)) {
                        return output
                    }
                    lastCoverageForJmp[cursor.toString] = coverage
                    lastLoopVarStateForJmp[cursor.toString] = memory[mem]
                }
            }

            history.push([cursor, memory])
            
        }

        return output
    }

    function genJump(turing, varIdx, label) {
        const outs = turing
            .map((x,i) => [x[0], x[1], i])
            .filter(x => x[1] === 0n)
            .map(x => [x[0], x[2]]) //char, line_no

            
        const instrPointer = find(outs, label)[0][1] //take first label
        return [varIdx, instrPointer + TURING_OFFSET]
    }

    function genStubJmp(turing, varIdx) {
        return [varIdx, BigInt(turing.length) + TURING_OFFSET]
    }


    function genInc(varIdx) {
        return [[varIdx, TURING_INC]]
    }

    function genDec(varIdx) {
        return [[varIdx, TURING_DEC]]
    }

    function genOut(next) {
        return [[next[0], 0n]]
    }



</script>

<script>
    //prediction

    const find = (state, pattern) => {
        const result = [];
        if (pattern.length === 0) {
            return state.map(() => undefined);
        }

        for (let i = 0; i <= state.length - pattern.length; i++) {
            let match = true;
            for (let j = 0; j < pattern.length; j++) {
                if (state[i + j][0] !== pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                const nextCh = state[i + pattern.length]
                if (nextCh) {
                    result.push(nextCh);
                }
            }
        }

        return result;
    }

    const unique = (state, pattern) => {
       return find(state, pattern).length === 1
    }

    const exists = (state, pattern) => {
        return find(state, pattern).length >= 1
    }

    const many = (state, pattern) => {
        return find(state, pattern).length > 1
    }

    const none = (state, pattern) => {
        return find(state, pattern).length === 0
    }

    const predict = (state, ctx = {}) => {
        if (state.length === 0) return undefined;

        let previousMany = null;

        const target = ctx.target ?? 1

        for (let len = 1; len <= state.length; len++) {
            const pattern = state.slice(state.length - len); 
            const matches = find(state.slice(0, -len), pattern.map(x => x[0]));

            ctx.n = len

            if (matches.length <= target) {
                if (matches.length === 0) return previousMany
                return matches;
            }

            if (matches.length > target) {
                previousMany = matches;
                continue;
            }

            if (previousMany) {
                return previousMany
            }
        }

        return undefined;
    }

    function predictDeterministic(state, ctx = {}) {
        let result = predict(state, ctx); 
        ctx.roll = false 
        ctx.nores = false

        if (!result || result.length === 1) {
            ctx.nores = true
            return result?.[0] ?? result;
        }

        while (Array.isArray(result) && result.length > 1) {
            const refined = predict(result);
            if (!refined) break;
            if (refined.length === 1) {
                result = refined;
                break;
            }
            result = refined;
        }


        if (result.length > 1) {
            ctx.roll = true
        }

        return result[0]
    }

    function pairEquals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }

    function checkRepeat(output) {
        const n = output.length;
        if (n === 0) return false;

        const pi = new Array(n).fill(0);

        for (let i = 1; i < n; i++) {
            let j = pi[i - 1];
            while (j > 0 && !pairEquals(output[i], output[j])) {
                j = pi[j - 1];
            }
            if (pairEquals(output[i], output[j])) j++;
            pi[i] = j;
        }

        const period = n - pi[n - 1];
        if (pi[n - 1] > 0 && n % period === 0) {
            return period;          // length of the minimal repeating block
        }
        return 0;
    }

    function maxValueBy(array, iteratee) {
        if (!Array.isArray(array) || array.length === 0) return undefined;
        const fn = typeof iteratee === 'function' ? iteratee : (o) => o[iteratee];
        let bestVal = fn(array[0]);
        for (let i = 1; i < array.length; i++) {
            const val = fn(array[i]);
            if (val > bestVal) bestVal = val;
        }
        return bestVal;
    }

    function countUniqueBy(array, predicate) {
        if (!Array.isArray(array) || array.length === 0) return 0;
        const fn = typeof predicate === 'function' ? predicate : (o) => o[predicate];
        const seen = new Set();
        for (const item of array) seen.add(fn(item));
        return seen.size;
    }


    function inlineTuring(next, state, output, ctx) {
        if (ctx.turing === undefined) ctx.turing = []
        if (ctx.unresolvedLabels === undefined) ctx.unresolvedLabels = {}
        if (ctx.varCount === undefined) ctx.varCount = 0n
        if (ctx.vars === undefined) ctx.vars = {}
        if (ctx.varIdx === undefined) ctx.varIdx = {}

        const predictCtx = {target: 2}
        const branches = predict([...state, next], predictCtx)

        const lookForwardCtx = {order: true}
        
        const found = zeroBranch([...state, next], predictContinuously([...state, next], lookForwardCtx))

        if (found !== undefined && branches.length > 1) {



            if (!ctx.vars[found.varName]) {
                ctx.varCount++
                ctx.vars[found.varName] = found
                ctx.varIdx[found.varName] = ctx.varCount
            }

            //infer more sequential chars for unique label token (from output) not followed by zero
            const labelSuffix = undefined

            const varIdx = ctx.varIdx[found.varName]
            const label = state.slice(-predictCtx.n)

            if (labelSuffix) {
                ctx.turing.push(genJump(turing, varIdx, eraseSeqNo(label.concat(labelSuffix))))
            } else {
                ctx.turing.push(genStubJmp(ctx.turing, varIdx))
                ctx.unresolvedLabels[parse(label)] = ctx.turing.length - 1
            }
            
        } else {
            //check if previous sequence matches one of inc/dec tokens
            
            const getIdx = (incOrDec) => {
                for (const [name, zero] of Object.entries(ctx.vars)) {
                    if (checkIfEndsWithToken(output, zero[incOrDec])) {
                        return ctx.varIdx[name]
                    }
                }
                return undefined
            }
            
            const incIdx = getIdx("incs")
            const decIdx = getIdx("decs")
            if (incIdx) {
                ctx.turing.push(genInc(incIdx))
            } 
            if (decIdx) {
                ctx.turing.push(genDec(decIdx))
            }
        }

        // TODO check if next sequence matches one of unresolved labels
        // enrich corresponding jump with it

        ctx.turing.push(genOut(next))


    }

    function predictContinuously(initState, ctx = {}) {
        if (ctx.turing) {
            return enrichSeqNo(executeTuring(ctx.turing))
        }

        let state = [...initState];
        const output = [];

        ctx.loop = false

        let counter = 0

        while (true) {
            counter++
            

            let next = predictDeterministic(state);

            if (ctx.order && output.length > 0) {
                if (next[1] !== output[output.length - 1][1] + 1) {
                    return output
                }
            }

            if (ctx.inlineTuring) {
               inlineTuring(next, state, output, ctx)
            }
       
            if (!next) break;
            output.push(next);

            const limit = countUniqueBy(output, x => x[1])

            if (counter > limit) {
                output.forEach(el => {
                    el[1] = 0
                })
            }

            if (counter > 1000) {
                throw "overflow " + parse(state) + "\n" + output.map(x => `${x[1]}: ${parse([x])}\n`).join('')
            }

            const repeatLen = checkRepeat(output)
            //const repeatLen = checkRepeat(output.map(x => [x[0], 0]));
            if (repeatLen > 0) {
                
                const keep = output.length - repeatLen; 
                output.splice(keep, repeatLen);
                ctx.loop = true
                break;                                  
            }

           
            state = [...state, next]; 
        }

        if (ctx.executeTuring && ctx.turing) {
            return predictContinuously(initState, ctx)
        }

        return output  
    }


</script>


<script>
    
    //const state = render(" Welcome to the terminal! Welcome to the world! Welcome to the terminal! Welcome to the world! Welcome")
    const state = render("0+-0++pl:---l0--l0-lp")
    //const state = render("+-0+++l-l0")

    console.log("N:" + state.slice(-1)[0][1])
    tg("br")

    const span2 = tg("span", "res")
    span2.textContent = parse(find(state, render("l").map(x => x[0])))
    span2.style.color = "green"

    tg("br")

    const span7 = tg("span", "res")
    const ctx7 = {target:2}
    span7.textContent = "" + parse(predict(state, ctx7))
    span7.style.color = "green"

    tg("br")

    const span3 = tg("span", "res")
    const ctx = {}
    span3.textContent = "PREDICT: " + parse([predictDeterministic(state, ctx)]) + "; n = " + ctx.n + "; roll = " + ctx.roll + "; nores = " + ctx.nores
    span3.style.color = "green"

    tg("br")


    const ctx2 = {}
    //ctx2.order = true
    ctx2.inlineTuring = true
    const span4 = tg("span", "res")
    span4.textContent = "STREAM: " + parse(predictContinuously(state, ctx2)) + "   ;;; loop = " + ctx2.loop + " ;;; turingLength=" + ctx2.turing.length
    span4.style.color = "green"

    console.log(ctx2)


    tg("br")
    tg("br")
    const span5= tg("span", "res")
    const ctx3 = {}
    console.log("BRANCHING")
    //span5.textContent = "BRANCHING: " + parse(predictContinuously(render("0+-0+++l -l0l"), ctx3)) + "  ;; branches = " + ctx3.branch
    span5.textContent = "BRANCHING: " + parseIncDec(inferIncDec(eraseSeqNo(render("0+-0++l:-l0l")), eraseSeqNo(render("0"))))
    span5.style.color = "green"
</script>


</html>